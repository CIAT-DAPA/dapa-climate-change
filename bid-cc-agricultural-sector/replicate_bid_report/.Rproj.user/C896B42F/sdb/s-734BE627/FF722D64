{
    "collab_server" : "",
    "contents" : "\ng <- gc(); rm(list = ls())\n\n# R options\noptions(warn = -1); options(scipen = 999); OSys <- Sys.info(); OSys <- OSys[names(OSys)==\"sysname\"]\n\nif(OSys == \"Windows\"){\n  setwd(\"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector/22-Redo-BID-report\")\n} else {\n  if(OSys == \"Linux\"){\n    setwd(\"/mnt/workspace_cluster_3/bid-cc-agricultural-sector/22-Redo-BID-report\")\n  }\n}\n\n# Load libraries\nsuppressMessages(library(Hmisc))\nsuppressMessages(library(raster))\nsuppressMessages(library(ggplot2))\nsuppressMessages(library(reshape))\nsuppressMessages(library(RColorBrewer))\n\n# Escoger parametros de interes\nparams <- c('HWAH','H.AM','IRCM','CWAM','TMAXA','TMINA')\n\ncrops <- c('Maize', 'Rice', 'Soybean', 'Bean', 'Wheat')\n\nlapply(1:length(crops), function(i){\n  \n  cat(paste(\"\\n\\n========= Processing \", crops[i], \" =========\\n\", sep = \"\"))\n  \n  if(crops[i] == \"Maize\"){variedades <- c(\"H6\", \"FM6\", \"MCCURDY6714\")}\n  if(crops[i] == \"Rice\"){variedades <- c(\"IR8\", \"IR72\", \"IR64\")}\n  if(crops[i] == \"Soybean\"){variedades <- c(\"Hutcheson\", \"DONMARIO\")}\n  if(crops[i] == \"Bean\"){variedades <- c(\"ICTAOstua\", \"Carioca\", \"A193\", \"BAT881\", \"Manitou\", \"Perola\", \"BRSRadiante\")}\n  if(crops[i] == \"Wheat\"){variedades <- c(\"Seri82BA\", \"TajanBA\", \"DonErnestoBA\", \"Gerek79BA\", \"HalconsnaBA\", \"BrigadierBA\")}\n  \n  # Set paths\n  if(OSys == \"Windows\"){\n    path.res = \"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector/19-BID-reanalysis\" # Results directory\n    path.root = \"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector\" # Root path\n  } else {\n    if(OSys == \"Linux\"){\n      path.res = \"/mnt/workspace_cluster_3/bid-cc-agricultural-sector/19-BID-reanalysis\" # Results directory\n      path.root = \"/mnt/workspace_cluster_3/bid-cc-agricultural-sector\" # Root path\n    }\n  }\n  carp.res.riego = \"historical/final\"\n  carp.res.secano = \"historical/final\"\n  \n  # Otros datos fijos\n  regions = c('MEX', 'CEN', 'AND', 'BRA', 'SUR')\n  treat = c('riego', 'secano') # riego o secano (which to plot)\n  treat.en = c('Irrigated', 'Rainfed')\n  cultivos = c('maiz', 'arroz', 'soya', 'frijol', 'trigo')\n  cultivos.en = c('Maize', 'Rice', 'Soybean', 'Bean', 'Wheat')\n  anos = 1:28 # Fijar year para analizar aqui\n  anos2 = 1971:1998\n  \n  # Load pixel id's\n  eval(parse(text = paste('load(\"', path.root, '/08-Cells_toRun/matrices_cultivo/version2017/', cultivos.en[i], '_riego.Rdat\")', sep = '')))  #08-Cells_toRun/\n  eval(parse(text = paste('load(\"', path.root, '/08-Cells_toRun/matrices_cultivo/version2017/', cultivos.en[i], '_secano.Rdat\")', sep = '')))\n  \n  # Load mapas de Latinoamerica\n  eval(parse(text = paste('Map_LatinAmerica <- shapefile(\"', path.root, '/03-Map_LatinAmerica/Latino_America.shp\")', sep = '')))\n  Map_LatinAmerica1 <- fortify(Map_LatinAmerica)\n  \n  # Set graphing limits\n  xlim.c = c(-116, -35)\n  ylim.c = c(-54, 32)\n  cex.c = 0.5\n  \n  # Get list of climate models\n  models = read.table(paste(path.root, '/_documentos/ModelosGCM.csv', sep = ''), header = T, sep = ',', stringsAsFactors = F)\n  models = rbind(models, 'Historical baseline', 'Future multi-GCM average')\n  p = dim(models)[1]\n  colnames(models) = 'Models'  #hack for now (machetazo)\n  \n  # load, unlist and extract yield data to arrays (gridcells x years x models)\n  # initialize arrays\n  yld_secano = array(NA, dim = c(dim(crop_secano)[1], 30, (p-1), length(variedades)))  #pixels x years x models x varieties\n  yld_riego = array(NA, dim = c(dim(crop_riego)[1], 30, (p-1), length(variedades)))\n  \n  for(v in 1:length(variedades)){\n    \n    for(m in 1:10){ # fija indices de modelos para incluir\n      \n      # print(m)\n      \n      # Load & extract baseline data from list\n      if(m <= 9){\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/future/final/SOY_rainfed_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/future/final/', toupper(crops[i]), '_rainfed_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        }\n      } else {\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/', carp.res.secano, '/SOY_rainfed_', variedades[v], '_WFD.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/', carp.res.secano, '/', toupper(crops[i]), '_rainfed_', variedades[v], '_WFD.Rdat', sep = ''))\n        }\n      }\n      Run.secano = Run\n      if(m <= 9){\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/future/final/SOY_irrigation_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/future/final/', toupper(crops[i]), '_irrigation_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        }\n      } else {\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/', carp.res.riego, '/SOY_irrigation_', variedades[v], '_WFD.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/', carp.res.riego, '/', toupper(crops[i]), '_irrigation_', variedades[v], '_WFD.Rdat', sep = ''))\n        }\n      }\n      Run.riego = Run\n      \n      # Unlist everything into matrices\n      secano = array(NA, dim = c(length(Run.secano), 30)) # Initialize arrays\n      for(j in 1:length(Run.secano)){\n        if(is.null(dim(Run.secano[[j]]))){\n          secano[j,] = 0\n        } else {\n          if(m == 10){\n            ind.s = as.numeric(substr(Run.secano[[j]][,1], 1, 4)) - 1970\n          }  else {\n            ind.s = as.numeric(substr(Run.secano[[j]][,1], 1, 4)) - 2020\n          }\n          if(ind.s[1] == 0){ind.s = ind.s +1}\n          secano[j, ind.s] = Run.secano[[j]][,'HWAH']\n        }\n      }\n      riego = array(NA, dim = c(length(Run.riego), 30))\n      for(j in 1:length(Run.riego)){\n        if(is.null(dim(Run.riego[[j]]))){\n          riego[j,] = 0\n        } else {\n          if(m == 10){\n            ind.r = as.numeric(substr(Run.riego[[j]][,1], 1, 4)) - 1970\n          } else {\n            ind.r = as.numeric(substr(Run.riego[[j]][,1], 1, 4)) - 2020\n          }\n          if(ind.r[1] == 0){ind.r = ind.r + 1}\n          riego[j, ind.r] = Run.riego[[j]][,'HWAH']\n        }\n      }\n      \n      # place results in array\n      yld_secano[,,m,v] = secano\n      yld_riego[,,m,v] = riego\n    }\n  }\n  \n  # Descartar los years sin datos climaticos, luego reemplaza -99 con 0 (para fallas); no debe existir fallas en DSSAT por razones tecnicas!\n  yld_secano = yld_secano[,anos,,] # Incluir los indices de los years \"buenos\" aqui con datos por todos los pixeles\n  yld_riego = yld_riego[,anos,,]\n  yld_secano[yld_secano == -99] = 0 # Re-emplazar -99 con 0 for legitimate crop failures\n  yld_riego[yld_riego == -99] = 0\n  \n  # #Check median durations by variety\n  # quantile(c(yld_secano[,,10,1,2],yld_riego[,,10,1,2]),na.rm=T)\n  \n  # Identify best variety in historical baseline (higher mean yields & less crop failures)\n  # across all 3 varieties\n  wfd.r = apply(yld_riego[,,(p-1),], c(1, 3), mean, na.rm = T) # multi-annual means\n  wfd.s = apply(yld_secano[,,(p-1),], c(1, 3), mean, na.rm = T)\n  thresh = mean(yld_secano[,,(p-1),], na.rm = T) * 0.2 # define crop failure as 20% of mean rainfed yield\n  wfd.fail.r = apply(yld_riego[,,(p-1),], c(1, 3), function(x) sum(x < thresh, na.rm = T)) # multi-annual means\n  wfd.fail.s = apply(yld_secano[,,(p-1),], c(1, 3), function(x) sum(x < thresh,na.rm = T))\n  \n  # Highest-yielding variety\n  wfd.r.high = apply(wfd.r, 1, which.max)\n  wfd.s.high = apply(wfd.s, 1, which.max)\n  \n  # Least crop failures\n  wfd.r.lowFail = apply(wfd.fail.r, 1, which.min)\n  wfd.s.lowFail = apply(wfd.fail.s, 1, which.min)\n  \n  # High-yielding and no more than 4 crop failures (15%)\n  if(crops[i] %in% c(\"Maize\", \"Rice\")){\n    \n    wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n    for (j in 1:dim(wfd.s)[1])  {\n      sortYield = sort.list(wfd.s[j,], dec = T)\n      if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n        if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n          if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n            wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n    }\n    \n    wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n    for (j in 1:dim(wfd.r)[1])  {\n      sortYield = sort.list(wfd.r[j,], dec = T) \n      if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n        if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n          if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n            wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n    }\n    \n  } else {\n    if(crops[i] == \"Soybean\"){\n      \n      wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n      for (j in 1:dim(wfd.s)[1])  {\n        sortYield = sort.list(wfd.s[j,], dec = T)\n        if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n          if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n            wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n      \n      wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n      for (j in 1:dim(wfd.r)[1])  {\n        sortYield = sort.list(wfd.r[j,], dec = T) \n        if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n          if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n            wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n      \n    } else {\n      if(crops[i] == \"Bean\"){\n        \n        wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n        for (j in 1:dim(wfd.s)[1])  {\n          sortYield = sort.list(wfd.s[j,], dec = T)\n          if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n            if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n              if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n                if (wfd.fail.s[j,sortYield[4]] <= 4) {wfd.s.best[j] = sortYield[4]} else{\n                  if (wfd.fail.s[j,sortYield[5]] <= 4) {wfd.s.best[j] = sortYield[5]} else{\n                    if (wfd.fail.s[j,sortYield[6]] <= 4) {wfd.s.best[j] = sortYield[6]} else{\n                      if (wfd.fail.s[j,sortYield[7]] <= 4) {wfd.s.best[j] = sortYield[7]} else{\n                        wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        \n        wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n        for (j in 1:dim(wfd.r)[1])  {\n          sortYield = sort.list(wfd.r[j,], dec = T) \n          if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n            if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n              if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n                if (wfd.fail.r[j,sortYield[4]] <= 4) {wfd.r.best[j] = sortYield[4]} else{\n                  if (wfd.fail.r[j,sortYield[5]] <= 4) {wfd.r.best[j] = sortYield[5]} else{\n                    if (wfd.fail.r[j,sortYield[6]] <= 4) {wfd.r.best[j] = sortYield[6]} else{\n                      if (wfd.fail.r[j,sortYield[7]] <= 4) {wfd.r.best[j] = sortYield[7]} else{\n                        wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        \n      } else {\n        if(crops[i] == \"Wheat\"){\n          \n          wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n          for (j in 1:dim(wfd.s)[1])  {\n            sortYield = sort.list(wfd.s[j,], dec = T)\n            if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n              if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n                if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n                  if (wfd.fail.s[j,sortYield[4]] <= 4) {wfd.s.best[j] = sortYield[4]} else{\n                    if (wfd.fail.s[j,sortYield[5]] <= 4) {wfd.s.best[j] = sortYield[5]} else{\n                      if (wfd.fail.s[j,sortYield[6]] <= 4) {wfd.s.best[j] = sortYield[6]} else{\n                        wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          \n          wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n          for (j in 1:dim(wfd.r)[1])  {\n            sortYield = sort.list(wfd.r[j,], dec = T) \n            if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n              if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n                if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n                  if (wfd.fail.r[j,sortYield[4]] <= 4) {wfd.r.best[j] = sortYield[4]} else{\n                    if (wfd.fail.r[j,sortYield[5]] <= 4) {wfd.r.best[j] = sortYield[5]} else{\n                      if (wfd.fail.r[j,sortYield[6]] <= 4) {wfd.r.best[j] = sortYield[6]} else{\n                        wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          \n        }\n      }\n    }\n  }\n  \n  # Just pick highest-yielding by growth habit for dry bean\n  if(crops[i] == 'Bean'){ # check highest yielding by country according to growth habit\n    habit = read.table(paste0(path.root, '/_documentos/Bean_growthHabit.csv'), header = T, sep = ',')\n    for(t in 1:2){\n      eval(parse(text = paste(\"meso = match(crop_\", treat[t], \"$country, habit$X[habit$Mesoamerican == 1])\", sep = \"\")))\n      ind.meso = which(is.na(meso) == F)\n      ind.andean = which(is.na(meso))\n      eval(parse(text = paste(\"meso.high = apply(wfd.\", substr(treat[t], 1, 1), \"[ind.meso, 1:2], 1, which.max)\", sep = \"\")))\n      eval(parse(text = paste(\"andean.high = apply(wfd.\", substr(treat[t], 1, 1), \"[ind.andean, 3:4], 1, which.max)+2\", sep = \"\")))\n      eval(parse(text = paste(\"wfd.\", substr(treat[t], 1, 1), \".best[ind.meso] = meso.high\", sep = \"\")))\n      eval(parse(text = paste(\"wfd.\", substr(treat[t], 1, 1), \".best[ind.andean] = andean.high\", sep = \"\")))\n    }\n  }\n  \n  # Select variety with highest yields for every pixel, all params \n  yld_secano.2 <- yld_secano # make backup with varieties\n  yld_riego.2 <- yld_riego\n  yld_secano <- array(NA, dim = c(dim(crop_secano)[1], length(anos), (p-1), length(params))) # pixels x years x models x params\n  yld_riego <- array(NA, dim = c(dim(crop_riego)[1], length(anos), (p-1), length(params)))\n  for(k in 1:length(variedades)){\n    yld_secano[wfd.s.best==k,,,] = yld_secano.2[wfd.s.best==k,,k,] # yld_secano[wfd.s.best==k,,,] = yld_secano.2[wfd.s.best==k,,,k,]\n    yld_riego[wfd.r.best==k,,,] = yld_riego.2[wfd.r.best==k,,k,] # yld_riego[wfd.r.best==k,,,] = yld_riego.2[wfd.r.best==k,,,k,]\n  }\n  \n  # #check average seasonal temperatures for WFD  (assumes tmax & tmin are params 3 & 4)\n  # wfd.s.tmax = apply(yld_secano[,,10,5],1,mean,na.rm=T)\n  # wfd.s.tmin = apply(yld_secano[,,10,6],1,mean,na.rm=T)\n  # wfd.s.tavg = (wfd.s.tmax + wfd.s.tmin)/2\n  # wfd.r.tmax = apply(yld_riego[,,10,5],1,mean,na.rm=T)\n  # wfd.r.tmin = apply(yld_riego[,,10,6],1,mean,na.rm=T)\n  # wfd.r.tavg = (wfd.r.tmax + wfd.r.tmin)/2\n  # wfd.tavg = c(wfd.s.tavg,wfd.r.tavg)\n  # areas = c(crop_secano$secano.area,crop_riego$riego.area)\n  # ind.na = which(is.na(wfd.tavg))\n  # if (length(ind.na)>0) {\n  #   wfd.tavg = wfd.tavg[-ind.na]\n  #   areas = areas[-ind.na]\n  # }\n  # sum(wfd.tavg * areas)/sum(areas)\n  \n  # Filter out bad pixels with excess crop failures\n  # Contar # de NA y 0 en rendimiento\n  riego.fallas <- apply(yld_riego[,,,1], c(1, 3), function(x) sum(is.na(x) | x == 0))\n  secano.fallas <- apply(yld_secano[,,,1], c(1, 3), function(x) sum(is.na(x) | x == 0))\n  \n  # Filtrar pixeles con muchas fallas en WFD\n  ind.bad.r <- which(riego.fallas[,10] >= 14) # half of total years\n  ind.bad.s <- which(secano.fallas[,10] >= 14)\n  if(length(ind.bad.r) > 0){\n    yld_riego   <- yld_riego[-ind.bad.r,,,]\n    crop_riego2 <- crop_riego # make backup of original\n    crop_riego  <- crop_riego[-ind.bad.r,]\n  }\n  if(length(ind.bad.s) > 0){\n    yld_secano <- yld_secano[-ind.bad.s,,,]\n    crop_secano2 <- crop_secano # make backup of original\n    crop_secano <- crop_secano[-ind.bad.s,]\n  }\n  \n  # Filter out irrigated pixels with no irrigation at all in historical baseline\n  test <- apply(yld_riego[,,10,3], 1, mean, na.rm = T)  #check multi-annual mean in baseline period of irrigation applied\n  ind.rain <- which(test == 0)\n  length(ind.rain)/dim(yld_riego)[1]*100  #check % of pixels, shouldn't be too high\n  if(length(ind.rain) > 0){\n    yld_riego <- yld_riego[-ind.rain,,,]\n    crop_riego <- crop_riego[-ind.rain,]\n  }\n  \n  # Identify locations of crop failures and reset ancillary variables to NA\n  for(m in 1:10){\n    \n    ind.fail.s = which(yld_secano[,,m,1] == 0 | is.na(yld_secano[,,m,1]), arr.ind = T) # Indices of crop failures for a given model\n    ind.fail.r = which(yld_riego[,,m,1] == 0 | is.na(yld_riego[,,m,1]), arr.ind = T)\n    \n    if(length(ind.fail.s) > 0){\n      for(v in 2:length(params)){\n        test <- yld_secano[,,m,v] # pull out matrix\n        test[ind.fail.s] <- NA # reset values\n        yld_secano[,,m,v] <- test # put it back\n      }\n    }\n    \n    if(length(ind.fail.r) > 0){\n      for(v in 2:length(params)){\n        test <- yld_riego[,,m,v] # pull out matrix\n        test[ind.fail.r] <- NA # reset values\n        yld_riego[,,m,v] <- test # put it back\n      }\n    }\n  }\n  \n  # Set variable to graph here!!!\n  lapply(1:length(params), function(z){\n    \n    var.g <- z  #var.g = 4 is yield/IRCM for irrigation productivity\n    cat(paste(\"Processing parameter: \", params[var.g], \"\\n\", sep = \"\"))\n    # params = c(params,'YPIM')\n    # params = c(params,'SRADT') # total accumulated radiation, SRADA*NDCH\n    # params = c(params,'PRCP.ET') # precip to ET ratio (PRCP/ETCP)\n    # params = c(params,'GRWT') # grain weight, i.e. HWAH/H.AM/10 (g/grain)\n    # params = c(params,'PRCPA') # precip divided by duration\n    \n    # Switch to look only at non-crop failures for yields (Tables 5 & 6 in paper)\n    yld.na <- F  #should leave at F by default\n    \n    # Calculate multi-annual means for var.g\n    if(params[var.g] == 'YPIM'){\n      wfd.r1 = yld_riego[,,(p-1),1]\n      wfd.r1[wfd.r1 == 0] = NA # reset 0's to NA\n      wfd.r1 = apply(wfd.r1, 1, mean, na.rm = T) # yield\n      wfd.s1 = yld_secano[,,(p-1),1]\n      wfd.s1[wfd.s1 == 0] = NA\n      wfd.s1 = apply(wfd.s1, 1, mean, na.rm = T) # yield\n      models.r1 = apply(yld_riego[,,1:(p-2),1], c(1, 3), mean, na.rm = T) # multi-annual means\n      models.s1 = apply(yld_secano[,,1:(p-2),1], c(1, 3), mean, na.rm = T)\n      \n      wfd.r3 = apply(yld_riego[,,(p-1),3], 1, mean, na.rm = T) # irrigation\n      wfd.s3 = apply(yld_secano[,,(p-1),3], 1, mean, na.rm = T)\n      models.r3 = apply(yld_riego[,,1:(p-2),3], c(1, 3), mean, na.rm = T) # multi-annual means\n      models.s3 = apply(yld_secano[,,1:(p-2),3], c(1, 3), mean, na.rm = T)\n      \n      models.r3[models.r3 == 0] <- 0.1 # reset 0 irrigation to 0.1 to avoid dividing by zero\n      wfd.r = wfd.r1/wfd.r3  #calculate yield to irrigation ratio\n      models.r = models.r1/models.r3\n      wfd.s = wfd.s1/wfd.s3  #secano, doesn't matter, zero irrigation\n      models.s = models.s1/models.s3\n      \n    } else {\n      if(params[var.g] == 'SRADT') { # total intercepted radiation\n        \n        sradt.s = yld_secano[,,,4] * yld_secano[,,,5] # double-check these positions!\n        sradt.r = yld_riego[,,,4] * yld_riego[,,,5]\n        \n        wfd.r = apply(sradt.r[,,10], 1, mean, na.rm = T) # multi-annual means\n        wfd.s = apply(sradt.s[,,10], 1, mean, na.rm = T)\n        models.r = apply(sradt.r[,,1:(p-2)], c(1, 3), mean, na.rm = T) # multi-annual means\n        models.s = apply(sradt.s[,,1:(p-2)], c(1, 3), mean, na.rm = T)\n        \n      } else {\n        if(params[var.g] == 'PRCP.ET'){\n          pret.s = yld_secano[,,,4] / yld_secano[,,,2] * 100 # assumes correct position!\n          pret.r = yld_riego[,,,4] / yld_riego[,,,2] * 100\n          \n          wfd.r = apply(pret.r[,,10], 1, mean, na.rm = T) # multi-annual means\n          wfd.s = apply(pret.s[,,10], 1, mean, na.rm = T)\n          models.r = apply(pret.r[,,1:(p-2)], c(1, 3), mean, na.rm = T) # multi-annual means\n          models.s = apply(pret.s[,,1:(p-2)], c(1, 3), mean, na.rm = T)\n          \n        } else {\n          if(params[var.g] == 'GRWT'){ # assumes correct position for HWAH & H.AM\n            yld.s = yld_secano[,,,1]\n            yld.s[yld.s == 0] = NA # put NA's for crop failures\n            yld.r = yld_riego[,,,1]\n            yld.r[yld.r == 0] = NA\n            grwt.s = yld.s / yld_secano[,,,2]\n            grwt.r = yld.r / yld_riego[,,,2]\n            \n            grwt.s[grwt.s == Inf] = NA # get rid of divide by zero errors (only happens with yield non-zero, but grain # zero)\n            grwt.r[grwt.r == Inf] = NA\n            \n            wfd.r = apply(grwt.r[,,10], 1, mean, na.rm = T) # multi-annual means\n            wfd.s = apply(grwt.s[,,10], 1, mean, na.rm = T)\n            models.r = apply(grwt.r[,,1:(p-2)], c(1, 3), mean, na.rm = T) # multi-annual means\n            models.s = apply(grwt.s[,,1:(p-2)], c(1, 3), mean, na.rm = T)\n            \n          } else {\n            if(params[var.g] == 'PRCPA'){\n              prcp.s = yld_secano[,,,4] / yld_secano[,,,2] # assumes correct position! (seasonal prcp/ duration)\n              prcp.r = yld_riego[,,,4] / yld_riego[,,,2]  \n              \n              wfd.r = apply(prcp.r[,,10], 1, mean, na.rm = T) # multi-annual means\n              wfd.s = apply(prcp.s[,,10], 1, mean, na.rm = T)\n              models.r = apply(prcp.r[,,1:(p-2)], c(1, 3), mean, na.rm = T) # multi-annual means\n              models.s = apply(prcp.s[,,1:(p-2)], c(1, 3), mean, na.rm = T)\n              \n            } else {\n              if(params[var.g] == 'HWAH' & yld.na == T){\n                wfd.r = yld_riego[,,(p-1),var.g] # extract data\n                wfd.r[wfd.r == 0] = NA # reset 0's to NA (without touching original data)\n                wfd.r = apply(wfd.r, 1, mean, na.rm = T)\n                \n                wfd.s = yld_secano[,,(p-1),var.g] # extract data\n                wfd.s[wfd.s == 0] = NA # reset 0's to NA (without touching original data)\n                wfd.s = apply(wfd.s, 1, mean, na.rm = T)\n                \n                models.r = yld_riego[,,1:(p-2),var.g]\n                models.r[models.r == 0] = NA\n                models.r = apply(models.r, c(1, 3), mean, na.rm = T)\n                \n                models.s = yld_secano[,,1:(p-2),var.g]\n                models.s[models.s == 0] = NA\n                models.s = apply(models.s, c(1, 3), mean, na.rm = T)\n                \n              } else {\n                wfd.r = apply(yld_riego[,,(p-1),var.g], 1, mean, na.rm = T) # multi-annual means\n                wfd.s = apply(yld_secano[,,(p-1),var.g], 1, mean, na.rm = T)\n                models.r = apply(yld_riego[,,1:(p-2),var.g], c(1, 3), mean, na.rm = T) # multi-annual means\n                models.s = apply(yld_secano[,,1:(p-2),var.g], c(1, 3), mean, na.rm = T)\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    quantile(wfd.s, c(.05, .95), na.rm = T)\n    quantile(wfd.r, c(.05, .95), na.rm = T)\n    \n    # Save out WFD values (modify name by yield type)\n    if(yld.na == T & params[var.g] == 'HWAH'){\n      save(wfd.r, wfd.s, file = paste(\"./resultados_graficas/\", crops[i], \"_WFD_\", params[var.g], \"_NA.Rdat\", sep = \"\"))\n    } else {\n      if(yld.na == F & params[var.g] == 'HWAH'){\n        save(wfd.r, wfd.s, file = paste(\"./resultados_graficas/\", crops[i], \"_WFD_\", params[var.g], \"_zeros.Rdat\", sep = \"\"))\n      } else {\n        save(wfd.r, wfd.s, file = paste(\"./resultados_graficas/\", crops[i], \"_WFD_\", params[var.g], \".Rdat\", sep = \"\"))\n      }\n    }\n    \n    # Repeat wfd for 9 models\n    wfd.r2 = replicate(9, wfd.r)\n    wfd.s2 = replicate(9, wfd.s)\n    \n    # Calculate % change from each model to WFD\n    if(params[var.g] == 'TMINA' | params[var.g] == 'TMAXA' | params[var.g] == 'Stress_water_all' | params[var.g] == 'Stress_water1' | params[var.g] == 'Stress_nitrogen_all' | params[var.g] == 'HIAM' | params[var.g] == 'PRCP.ET' | params[var.g] == 'IRCM'){\n      \n      pct.ch.r = (models.r-wfd.r2) # solo calcular diferencia\n      pct.ch.s = (models.s-wfd.s2)\n      \n    } else {\n      \n      pct.ch.r = (models.r-wfd.r2) / (wfd.r2) * 100 # calcular % de cambio\n      pct.ch.s = (models.s-wfd.s2) / (wfd.s2) * 100  \n      pct.ch.r[pct.ch.r == Inf] = NA # reset divide by zero errors to NA (shouldn't be many!)\n      pct.ch.s[pct.ch.s == Inf] = NA\n      \n    }\n    \n    quantile(c(pct.ch.r, pct.ch.s), c(.05, .95), na.rm = T)\n    quantile(c(wfd.s, models.s), c(.05, .95), na.rm = T)\n    quantile(c(wfd.r, models.r, wfd.s, models.s), c(.05, .95), na.rm = T)\n    \n    # Bootstrapping on percent change to get confidence intervals\n    # have to bootstrap for every pixel?\n    pct.ch.s2 = array(NA, dim = c(dim(crop_secano)[1], 3)) # mean plus CI\n    for(j in 1:dim(crop_secano)[1]){\n      boot = mat.or.vec(500, 1)\n      for(b in 1:500){\n        boot.ind = sample(1:(p-2), (p-2), replace = T)\n        boot[b] = mean(pct.ch.s[j, boot.ind])\n      }\n      pct.ch.s2[j, 1:2] = quantile(boot, c(.05, .95), na.rm = T)\n    }\n    \n    pct.ch.r2 = array(NA, dim = c(dim(crop_riego)[1], 3))\n    for(j in 1:dim(crop_riego)[1]){\n      boot = mat.or.vec(500, 1)\n      for(b in 1:500){\n        boot.ind = sample(1:(p-2), (p-2), replace = T)\n        boot[b] = mean(pct.ch.r[j, boot.ind])\n      }\n      pct.ch.r2[j, 1:2] = quantile(boot, c(.05, .95), na.rm = T)\n    }\n    \n    # Calculate multi-model means for % change and yields\n    pct.ch.s2[,3] = apply(pct.ch.s, 1, mean, na.rm = T)\n    pct.ch.r2[,3] = apply(pct.ch.r, 1, mean, na.rm = T)\n    mmm.s = apply(models.s, 1, mean, na.rm = T)\n    mmm.r = apply(models.r, 1, mean, na.rm = T)\n    \n    # Add another column to pct.ch putting NA for non-significant changes\n    pct.ch.r2 = cbind(pct.ch.r2, pct.ch.r2[,3])\n    ind.na.r = which(pct.ch.r2[,1] < 0 & pct.ch.r2[,2] > 0)\n    pct.ch.r2[ind.na.r, 4] = NA\n    \n    pct.ch.s2 = cbind(pct.ch.s2, pct.ch.s2[,3])\n    ind.na.s = which(pct.ch.s2[,1] < 0 & pct.ch.s2[,2] > 0)\n    pct.ch.s2[ind.na.s, 4] = NA\n    \n    # Add column for categorical changes\n    pct.ch.r2 = cbind(pct.ch.r2, NA)\n    pct.ch.r2[pct.ch.r2[,4] > 0, 5] = 1 # sig increases\n    pct.ch.r2[pct.ch.r2[,4] < 0, 5] = -1 # sig decreases\n    pct.ch.r2[is.na(pct.ch.r2[,4]), 5] = NA\n    \n    pct.ch.s2 = cbind(pct.ch.s2, NA)\n    pct.ch.s2[pct.ch.s2[,4] > 0, 5] = 1 # sig increases\n    pct.ch.s2[pct.ch.s2[,4] < 0, 5] = -1 # sig decreases\n    pct.ch.s2[is.na(pct.ch.s2[,4]), 5] = NA\n    \n    # Look at range of sig.ch values\n    quantile(c(pct.ch.s2[,4], pct.ch.r2[,4]), c(.05, .95), na.rm = T)\n    quantile(c(pct.ch.s2[,4]), c(.05, .95), na.rm = T)\n    quantile(c(pct.ch.r2[,4]), c(.05, .95), na.rm = T)\n    \n    # Look at mean weighted by harvested area\n    sum(pct.ch.s2[,4] * crop_secano$secano.area, na.rm = T) / sum(crop_secano$secano.area[is.na(pct.ch.s2[,4]) == F])\n    sum(pct.ch.r2[,4] * crop_riego$riego.area, na.rm = T) / sum(crop_riego$riego.area[is.na(pct.ch.r2[,4]) == F])\n    \n    # Add column names & reorder columns\n    pct.ch.r2 = cbind(pct.ch.r2[,3:4], pct.ch.r2[,1:2], pct.ch.r2[,5]) # re-order columns\n    pct.ch.s2 = cbind(pct.ch.s2[,3:4], pct.ch.s2[,1:2], pct.ch.s2[,5])\n    pct.ch.r2 = cbind(pct.ch.r2, crop_riego$riego.area, crop_riego$x, crop_riego$y) # add pixel-wise areas\n    pct.ch.s2 = cbind(pct.ch.s2, crop_secano$secano.area, crop_secano$x, crop_secano$y)\n    \n    pct.ch_cols = c('PctCh.MMM', 'SigCh.MMM', 'PctCh.lower', 'PctCh.upper', 'Categorical', 'Area', 'Lon', 'Lat')\n    colnames(pct.ch.s2) = pct.ch_cols\n    colnames(pct.ch.r2) = pct.ch_cols\n    models = rbind(models, 'PctCh.MMM', 'SigCh.MMM', 'PctCh.lower', 'PctCh.upper', 'Categorical') # concatenate for plotting purposes\n    \n    # Save vectors to compare across crops (modify name by yield type)\n    if(yld.na == T & params[var.g] == 'HWAH'){\n      \n      save(pct.ch.r2, file = paste(\"./resultados_graficas/\", crops[i], \"_riego_pctCh_\", params[var.g], \"_NA.Rdat\", sep = \"\"))\n      save(pct.ch.s2, file = paste(\"./resultados_graficas/\", crops[i], \"_secano_pctCh_\", params[var.g], \"_NA.Rdat\", sep = \"\"))\n      \n    } else {\n      \n      if(yld.na == F & params[var.g] == 'HWAH'){\n        \n        save(pct.ch.r2, file = paste(\"./resultados_graficas/\", crops[i], \"_riego_pctCh_\", params[var.g], \"_zeros.Rdat\", sep = \"\"))\n        save(pct.ch.s2, file = paste(\"./resultados_graficas/\", crops[i], \"_secano_pctCh_\", params[var.g], \"_zeros.Rdat\", sep = \"\"))\n        \n      } else {\n        \n        save(pct.ch.r2, file = paste(\"./resultados_graficas/\", crops[i], \"_riego_pctCh_\", params[var.g], \".Rdat\", sep = \"\"))\n        save(pct.ch.s2, file = paste(\"./resultados_graficas/\", crops[i], \"_secano_pctCh_\", params[var.g], \".Rdat\", sep = \"\"))\n        \n      }\n      \n    }\n    \n    for(t in 1:2){ # loop through riego (t=1)/ secano (t=2)\n      \n      print(t)\n      \n      for(m in c(p+1)){ # (p-1):(p+1):  WFD, multi-model mean y % cambio (4 tipos)\n        \n        # multi-annual means per model\n        if(m <= (p-1)){\n          \n          eval(parse(text = paste('promedio = apply(yld_', treat[t], '[,,m,var.g], 1, mean, na.rm = T)', sep = ''))) # average in zeros??\n          \n        } else {\n          \n          if(m == p){ # multi-model mean\n            \n            eval(parse(text = paste('promedio = mmm.', substr(treat[t], 1, 1), sep = '')))\n            \n          } else {\n            \n            if(m >= (p+1)){ # % change\n              \n              eval(parse(text = paste('promedio = pct.ch.', substr(treat[t], 1, 1), '2[,m-p]', sep = ''))) # change column with loop\n            }\n          }\n        }\n        \n        # set limits, color scale and labels\n        if(m <= p){ # for models + WFD\n          # promedio[promedio==0] = NA  #set 0 values to NA\n          # default values\n          limits2 = quantile(c(yld_riego[,,,var.g], yld_secano[,,,var.g]), c(.05, .95), na.rm = T) # limites flexibles segun el cultivo\n          labs2 = ''\n          color_scale = brewer.pal(9, 'YlGn')\n          \n          if(params[var.g] == 'HWAH'){\n            \n            promedio = promedio/1000 # convert from kg/ha to t/ha\n            labs2 = '      t/ha'\n            limits2 = quantile(c(yld_riego[,,,var.g]/1000, yld_secano[,,,var.g]/1000), c(.05, .95), na.rm = T) # reset limits\n            \n            if(c == 1 | c == 2 | c == 5){\n              \n              limits2 = c(0.9, 10.1)\n              \n            } else {\n              \n              limits2 = c(0.7, 5)\n              \n            } # limites fijados\n          }\n          if(params[var.g] == 'Stress_nitrogen_all'){\n            \n            limits2 = c(0, 0.45) # stress indices\n            \n          } \n          if(params[var.g] == 'Stress_water_all'){\n            \n            limits2 = c(0, 0.25) # stress indices, 0.305\n            labs2 = ''\n            \n          }\n          if(params[var.g] == 'NDCH'){\n            \n            limits2 = c(75, 175) # duration\n            labs2 = '    Days'\n            \n          }\n          if(params[var.g] == 'IRCM'){\n            \n            limits2 = quantile(c(yld_riego[,,,var.g]), c(.05, .95), na.rm = T)\n            limits2 = c(0, 300)\n            labs2 = '    Mm'\n            \n          }\n          if(params[var.g] == 'Stress_water_all' | params[var.g] == 'Stress_nitrogen_all'){\n            # color_scale = colorRampPalette(c('forestgreen','gold2','red'), space=\"rgb\")(25)\n            color_scale = brewer.pal(9, 'YlOrBr')\n          }\n          if(params[var.g] == 'IRCM'){\n            # color_scale = colorRampPalette(c('yellow','green','forestgreen','blue'), space=\"rgb\")(25)\n            color_scale =  brewer.pal(9, 'GnBu')\n          }\n          \n        } else { # categorical plots\n          if(m == 16){\n            \n            limits2 = c(-1, 1)\n            color_scale = brewer.pal(11, 'RdYlGn') # fix this!\n            labs2 = ''\n            \n          } else { # percent change plots\n            dat = c(pct.ch.r, pct.ch.s)\n            #limits2 = quantile(dat[dat<0],c(.025),na.rm=T)  \n            limits2 = max(abs(quantile(dat,c(.05, .95), na.rm = T)))\n            limits2 = sort(c(limits2, -1*limits2)) # set positive equal to opposite of negative\n            #color_scale = colorRampPalette(c('red','orangered','orange','lightyellow','lightgreen','green','forestgreen'), space=\"rgb\")(15)\n            color_scale = brewer.pal(11, 'RdYlGn')\n            labs2 = '      %'\n            \n            if(params[var.g] == 'TMAXA' | params[var.g] == 'TMINA'){\n              \n              limits2 = c(0, 3.5) # temperatura\n              color_scale = colorRampPalette(c('white', 'orange', 'red'), space = \"rgb\")(15)\n              \n            }\n            if(params[var.g] == 'HWAH' | params[var.g] == 'YPEM' | params[var.g] == 'SRADT'){\n              \n              limits2 = c(-50, 50) # rend y WUE\n              \n            }\n            if(params[var.g] == 'YPIM'){\n              \n              limits2 = c(-100, 100) # rend y WUE\n              \n            }\n            if(params[var.g] == 'NDCH'){\n              \n              limits2 = c(-12, 12) # duracion\n              \n            }\n            if(params[var.g] == 'Stress_water_all' | params[var.g] == 'Stress_nitrogen_all' || params[var.g] == 'Stress_water1'){\n              \n              limits2 = c(-0.08, 0.08) # stress indices\n              # color_scale = colorRampPalette(c('forestgreen','green','lightgreen','lightyellow','orange','orangered','red'), space=\"rgb\")(15)\n              color_scale = rev(brewer.pal(11, 'BrBG'))\n              labs2 = ''\n            }\n            if(params[var.g] == 'SRADA'){\n              \n              limits2 = c(-30, 30)\n              \n            }\n            if(params[var.g] == 'EPCM'){\n              \n              limits2 = c(-25, 25)\n              \n            } \n            if(params[var.g] == 'H.AM'){\n              \n              limits2 = c(-30, 30)\n              \n            }\n            if(params[var.g] == 'GRWT'){\n              \n              limits2 = c(-30, 30)\n              \n            }\n            if(params[var.g] == 'IRCM'){\n              dat = pct.ch.r\n              limits2 = max(abs(quantile(dat, c(.1, .9), na.rm = T)))\n              print(round(quantile(dat, c(.1, .9), na.rm = T), 2))\n              limits2 = sort(c(limits2, -1 * limits2))\n              limits2 = c(-100, 100)\n              labs2 = '    Mm'\n              # color_scale = colorRampPalette(c('red','orangered','orange','lightyellow','green','forestgreen','blue'), space=\"rgb\")(25)\n              color_scale = brewer.pal(9, 'RdYlBu')\n            }\n            #limits2 = c(-25,25)  #hard-code limits instead\n          }\n        }\n        \n        # get data ready for plotting\n        promedio[promedio < limits2[1]] = limits2[1] # reset end points of data to plotting limits\n        promedio[promedio > limits2[2]] = limits2[2]\n        eval(parse(text = paste(\"df = data.frame(Long = crop_\", treat[t], \"[,1], Lat = crop_\", treat[t], \"[,2], yield = promedio)\", sep = '')))\n        \n        #create ggplot & save\n        y = ggplot() +\n          geom_polygon(data = Map_LatinAmerica1, aes(x = long, y = lat, group = group), colour = \"gray80\", fill = \"white\" ) + # fill = \"gray70\"\n          geom_path(data = Map_LatinAmerica1, aes(x = long, y = lat, group = group), colour = \"black\", size = 0.25) +\n          coord_equal() +\n          geom_raster(data = df, aes(x = Long, y = Lat, fill = yield)) +\n          ggtitle(paste(capitalize(cultivos.en[i]), ' (', treat.en[t], '): \\n', models[m,], sep = '')) +\n          scale_fill_gradientn(colours = color_scale, limits = limits2, na.value = \"gray85\") + # guide='none' turns off legend,lightskyblue, limits ,breaks=as.vector(limits),labels=as.vector(limits),limits=as.vector(limits)\n          theme_bw() +\n          labs(fill = labs2) +\n          theme(panel.grid.major.x = element_blank(),\n                panel.grid.minor.x = element_blank(),\n                panel.grid.major.y = element_blank(),\n                panel.grid.minor.y = element_blank(),\n                axis.text.x = element_blank(),\n                axis.text.y = element_blank(),\n                axis.title.x = element_blank(),\n                axis.title.y = element_blank(),\n                legend.text = element_text(size = 16),\n                legend.title = element_text(face = \"bold\", size = 18),\n                legend.background = element_blank(),\n                legend.key = element_blank(),\n                legend.key.size = unit(1, 'cm'),\n                legend.justification = c(0, 0),\n                legend.position = c(0.2, 0.2), # baseline yields only!\n                plot.title = element_blank(), # element_text(face=\"bold\", size=18)  #this turns on or off plot title\n                panel.border = element_blank(),\n                axis.ticks = element_blank(),\n                plot.margin = unit(c(0, 0, 0, 0), \"mm\")\n          )\n        #plot(y)\n        ggsave(filename = paste(\"./resultados_graficas/\", crops[i], \"_\", treat[t], \"_bestVariety_\", models[m,], \"_\", params[var.g], \".png\", sep = \"\"), plot = y, width = 5, height = 5, dpi = 400, scale = 1.5)\n      }\n    }\n    \n  })\n  \n  return(\"Done!\\n\")\n  \n})\n",
    "created" : 1499615817060.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2010493201",
    "id" : "FF722D64",
    "lastKnownWriteTime" : 1501621220,
    "last_content_update" : 1501621220356,
    "path" : "D:/ToBackup/climate_and_crop_modelling/bid-cc-agricultural-sector/replicate_bid_report/Crop_maps_paper.R",
    "project_path" : "Crop_maps_paper.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}