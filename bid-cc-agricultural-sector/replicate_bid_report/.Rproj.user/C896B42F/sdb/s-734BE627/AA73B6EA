{
    "collab_server" : "",
    "contents" : "# Aggregate yields to country level to calculate % changes in yield and area at risk of crop failure\n\ng <- gc(); rm(list = ls())\n\n# R options\noptions(warn = -1); options(scipen = 999); OSys <- Sys.info(); OSys <- OSys[names(OSys)==\"sysname\"]\n\nif(OSys == \"Windows\"){\n  setwd(\"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector/22-Redo-BID-report\")\n} else {\n  if(OSys == \"Linux\"){\n    setwd(\"/mnt/workspace_cluster_3/bid-cc-agricultural-sector/22-Redo-BID-report\")\n  }\n}\n\n# Load libraries\nsuppressMessages(library(Hmisc))\nsuppressMessages(library(raster))\nsuppressMessages(library(ggplot2))\nsuppressMessages(library(reshape))\nsuppressMessages(library(RColorBrewer))\nsuppressMessages(library(gplots))\n\ncrops <- c('Maize', 'Rice', 'Soybean', 'Bean', 'Wheat')\n\nlapply(1:length(crops), function(i){\n  \n  if(crops[i] == \"Maize\"){variedades <- c(\"H6\", \"FM6\", \"MCCURDY6714\")}\n  if(crops[i] == \"Rice\"){variedades <- c(\"IR8\", \"IR72\", \"IR64\")}\n  if(crops[i] == \"Soybean\"){variedades <- c(\"Hutcheson\", \"DONMARIO\")}\n  if(crops[i] == \"Bean\"){variedades <- c(\"ICTAOstua\", \"Carioca\", \"A193\", \"BAT881\", \"Manitou\", \"Perola\", \"BRSRadiante\")}\n  if(crops[i] == \"Wheat\"){variedades <- c(\"Seri82BA\", \"TajanBA\", \"DonErnestoBA\", \"Gerek79BA\", \"HalconsnaBA\", \"BrigadierBA\")}\n  \n  # Set paths\n  if(OSys == \"Windows\"){\n    path.res = \"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector/19-BID-reanalysis\" # Results directory\n    path.root = \"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector\" # Root path\n  } else {\n    if(OSys == \"Linux\"){\n      path.res = \"/mnt/workspace_cluster_3/bid-cc-agricultural-sector/19-BID-reanalysis\" # Results directory\n      path.root = \"/mnt/workspace_cluster_3/bid-cc-agricultural-sector\" # Root path\n    }\n  }\n  carp.res.riego = \"historical/final\"\n  carp.res.secano = \"historical/final\"\n  \n  # Otros datos fijos\n  regions = c('MEX', 'CEN', 'AND', 'BRA', 'SUR')\n  treat = c('riego', 'secano') # riego o secano (which to plot)\n  treat.en = c('Irrigated', 'Rainfed')\n  cultivos = c('maiz', 'arroz', 'soya', 'frijol', 'trigo')\n  cultivos.en = c('Maize', 'Rice', 'Soybean', 'bean', 'wheat')\n  anos = 1:28  # Fijar years para analizar aqui\n  anos2 = 1971:1998\n  \n  # #classification 1\n  # NOR = c('Mexico','Cuba')\n  # CEN = c('Belize','Guatemala','Honduras','El Salvador','Nicaragua','Costa Rica','Panama','Dominican Republic','Jamaica','Haiti','Colombia','Venezuela','Trinidad and Tobago')\n  # BRA = c('Guyana','French Guiana','Brazil','Suriname')\n  # AND = c('Ecuador','Peru','Bolivia','Chile')\n  # SUR = c('Argentina','Uruguay','Paraguay')\n  # \n  # #classification 2\n  # NOR = c('Mexico','Cuba','Belize','Guatemala','Honduras','El Salvador','Nicaragua','Costa Rica','Panama','Dominican Republic','Jamaica','Haiti')\n  # AND = c('Colombia','Venezuela','Trinidad and Tobago','Ecuador','Peru','Bolivia')\n  # BRA = c('Guyana','French Guiana','Brazil','Suriname')\n  # SUR = c('Chile','Argentina','Uruguay','Paraguay')\n  \n  # Classification 3\n  NOR = c('Mexico','Cuba','Belize','Guatemala','Honduras','El Salvador','Nicaragua','Dominican Republic','Jamaica','Haiti')\n  CEN = c('Costa Rica','Panama','Colombia','Venezuela','Trinidad and Tobago','Guyana','French Guiana','Suriname')\n  AND = c('Ecuador','Peru','Bolivia')\n  BRA = c('Brazil','Paraguay')\n  SUR = c('Argentina','Uruguay','Chile')\n  \n  # Load pixel id's\n  eval(parse(text=paste('load(\"', path.root, '/08-Cells_toRun/matrices_cultivo/version2017/', cultivos.en[i], '_riego.Rdat\")', sep = '')))  #08-Cells_toRun/\n  eval(parse(text=paste('load(\"', path.root, '/08-Cells_toRun/matrices_cultivo/version2017/', cultivos.en[i], '_secano.Rdat\")', sep = '')))\n  \n  # get list of climate models\n  models = read.table(paste(path.root, '/_documentos/ModelosGCM.csv', sep = ''), header = T, sep = ',', stringsAsFactors = F)\n  models = rbind(models,'Historical baseline','Future multi-GCM average')\n  p = dim(models)[1]\n  colnames(models) = 'Models'  #hack for now (machetazo)\n  \n  # load, unlist and extract data to arrays (gridcells x years x models)\n  # initialize arrays\n  yld_secano = array(NA, dim = c(dim(crop_secano)[1], 30, (p-1), length(variedades)))  #10 GCM's + baseline\n  yld_riego = array(NA, dim = c(dim(crop_riego)[1], 30, (p-1), length(variedades)))\n  \n  for(v in 1:length(variedades)){\n    \n    for(m in 1:10){ # fija indices de modelos para incluir\n      \n      print(m)\n      \n      # Load & extract baseline data from list\n      if(m <= 9){\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/future/final/SOY_rainfed_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/future/final/', toupper(crops[i]), '_rainfed_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        }\n      } else {\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/', carp.res.secano, '/SOY_rainfed_', variedades[v], '_WFD.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/', carp.res.secano, '/', toupper(crops[i]), '_rainfed_', variedades[v], '_WFD.Rdat', sep = ''))\n        }\n      }\n      Run.secano = Run\n      if(m <= 9){\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/future/final/SOY_irrigation_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/future/final/', toupper(crops[i]), '_irrigation_', variedades[v], '_', models[m,], '.Rdat', sep = ''))\n        }\n      } else {\n        if(crops[i] == \"Soybean\"){\n          load(paste(path.res, '/', crops[i], '/', carp.res.riego, '/SOY_irrigation_', variedades[v], '_WFD.Rdat', sep = ''))\n        } else {\n          load(paste(path.res, '/', crops[i], '/', carp.res.riego, '/', toupper(crops[i]), '_irrigation_', variedades[v], '_WFD.Rdat', sep = ''))\n        }\n      }\n      Run.riego = Run\n      \n      # unlist everything into matrices\n      secano = array(NA, dim = c(length(Run.secano), 30))  #initialize arrays\n      for(j in 1:length(Run.secano)){\n        if(is.null(dim(Run.secano[[j]]))){\n          secano[j,,] = NA\n        } else {\n          secano[j, 1:dim(Run.secano[[j]])[1]] = as.numeric(as.character(Run.secano[[j]][,'HWAH']))\n        }\n      }\n      riego = array(NA, dim = c(length(Run.riego), 30))\n      for(j in 1:length(Run.riego)){\n        if(is.null(dim(Run.riego[[j]]))){\n          riego[j,,] = NA\n        }  else{\n          riego[j, 1:dim(Run.riego[[j]])[1]] = as.numeric(as.character(Run.riego[[j]][,'HWAH']))\n        }\n      }\n      \n      # place results in array\n      yld_secano[,,m,v] = secano\n      yld_riego[,,m,v] = riego\n      \n    }\n  }\n  \n  # Descartar los years sin datos climaticos, luego reemplaza -99 con 0 (para fallas); no debe existir fallas en DSSAT por razones tecnicas!\n  yld_secano = yld_secano[,anos,,] # incluir los indices de los a�os \"buenos\" aqu� con datos por todos los pixeles\n  yld_riego = yld_riego[,anos,,]\n  yld_secano[yld_secano == -99 | yld_secano == -99.9 | yld_secano == 9999999] = 0  #set crop failures to 0 yield\n  yld_riego[yld_riego == -99 | yld_riego == -99.9 | yld_riego == 9999999] = 0\n  \n  #Identify best variety in historical baseline (higher mean yields & less crop failures)\n  #across all 3 varieties\n  wfd.r = apply(yld_riego[,,(p-1),], c(1, 3), mean, na.rm = T) # multi-annual means\n  wfd.s = apply(yld_secano[,,(p-1),], c(1, 3), mean, na.rm = T)\n  thresh = mean(yld_secano[,,(p-1),], na.rm = T) * 0.2 # define crop failure as 20% of mean rainfed yield\n  wfd.fail.r = apply(yld_riego[,,(p-1),], c(1, 3), function(x) sum(x < thresh, na.rm = T)) # multi-annual means\n  wfd.fail.s = apply(yld_secano[,,(p-1),], c(1, 3), function(x) sum(x < thresh, na.rm = T))\n  \n  #highest-yielding variety\n  wfd.r.high = apply(wfd.r, 1, which.max)\n  wfd.s.high = apply(wfd.s, 1, which.max)\n  \n  #least crop failures\n  wfd.r.lowFail = apply(wfd.fail.r, 1, which.min)\n  wfd.s.lowFail = apply(wfd.fail.s, 1, which.min)\n  \n  # High-yielding and no more than 4 crop failures (15%)\n  if(crops[i] %in% c(\"Maize\", \"Rice\")){\n    \n    wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n    for (j in 1:dim(wfd.s)[1])  {\n      sortYield = sort.list(wfd.s[j,], dec = T)\n      if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n        if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n          if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n            wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n    }\n    \n    wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n    for (j in 1:dim(wfd.r)[1])  {\n      sortYield = sort.list(wfd.r[j,], dec = T) \n      if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n        if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n          if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n            wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n    }\n    \n  } else {\n    if(crops[i] == \"Soybean\"){\n      \n      wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n      for (j in 1:dim(wfd.s)[1])  {\n        sortYield = sort.list(wfd.s[j,], dec = T)\n        if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n          if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n            wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n      \n      wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n      for (j in 1:dim(wfd.r)[1])  {\n        sortYield = sort.list(wfd.r[j,], dec = T) \n        if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n          if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n            wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n      \n    } else {\n      if(crops[i] == \"Bean\"){\n        \n        wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n        for (j in 1:dim(wfd.s)[1])  {\n          sortYield = sort.list(wfd.s[j,], dec = T)\n          if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n            if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n              if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n                if (wfd.fail.s[j,sortYield[4]] <= 4) {wfd.s.best[j] = sortYield[4]} else{\n                  if (wfd.fail.s[j,sortYield[5]] <= 4) {wfd.s.best[j] = sortYield[5]} else{\n                    if (wfd.fail.s[j,sortYield[6]] <= 4) {wfd.s.best[j] = sortYield[6]} else{\n                      if (wfd.fail.s[j,sortYield[7]] <= 4) {wfd.s.best[j] = sortYield[7]} else{\n                        wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        \n        wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n        for (j in 1:dim(wfd.r)[1])  {\n          sortYield = sort.list(wfd.r[j,], dec = T) \n          if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n            if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n              if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n                if (wfd.fail.r[j,sortYield[4]] <= 4) {wfd.r.best[j] = sortYield[4]} else{\n                  if (wfd.fail.r[j,sortYield[5]] <= 4) {wfd.r.best[j] = sortYield[5]} else{\n                    if (wfd.fail.r[j,sortYield[6]] <= 4) {wfd.r.best[j] = sortYield[6]} else{\n                      if (wfd.fail.r[j,sortYield[7]] <= 4) {wfd.r.best[j] = sortYield[7]} else{\n                        wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        \n      } else {\n        if(crops[i] == \"Wheat\"){\n          \n          wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n          for (j in 1:dim(wfd.s)[1])  {\n            sortYield = sort.list(wfd.s[j,], dec = T)\n            if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n              if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n                if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n                  if (wfd.fail.s[j,sortYield[4]] <= 4) {wfd.s.best[j] = sortYield[4]} else{\n                    if (wfd.fail.s[j,sortYield[5]] <= 4) {wfd.s.best[j] = sortYield[5]} else{\n                      if (wfd.fail.s[j,sortYield[6]] <= 4) {wfd.s.best[j] = sortYield[6]} else{\n                        wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          \n          wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n          for (j in 1:dim(wfd.r)[1])  {\n            sortYield = sort.list(wfd.r[j,], dec = T) \n            if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n              if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n                if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n                  if (wfd.fail.r[j,sortYield[4]] <= 4) {wfd.r.best[j] = sortYield[4]} else{\n                    if (wfd.fail.r[j,sortYield[5]] <= 4) {wfd.r.best[j] = sortYield[5]} else{\n                      if (wfd.fail.r[j,sortYield[6]] <= 4) {wfd.r.best[j] = sortYield[6]} else{\n                        wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          \n        }\n      }\n    }\n  }\n  \n  # Just pick highest-yielding by growth habit for dry bean\n  if(crops[i] == 'Bean'){ # check highest yielding by country according to growth habit\n    habit = read.table(paste0(path.root, '/_documentos/Bean_growthHabit.csv'), header = T, sep = ',')\n    for(t in 1:2){\n      eval(parse(text = paste(\"meso = match(crop_\", treat[t], \"$country,habit$X[habit$Mesoamerican == 1])\", sep = \"\")))\n      ind.meso = which(is.na(meso) == F)\n      ind.andean = which(is.na(meso))\n      eval(parse(text = paste(\"meso.high = apply(wfd.\", substr(treat[t], 1, 1), \"[ind.meso, 1:2], 1, which.max)\", sep = \"\")))\n      eval(parse(text = paste(\"andean.high = apply(wfd.\", substr(treat[t], 1, 1), \"[ind.andean, 3:4], 1, which.max)+2\", sep = \"\")))\n      eval(parse(text = paste(\"wfd.\", substr(treat[t], 1, 1), \".best[ind.meso] = meso.high\", sep = \"\")))\n      eval(parse(text = paste(\"wfd.\", substr(treat[t], 1, 1), \".best[ind.andean] = andean.high\", sep = \"\")))\n    }\n  }\n  \n  # Select variety with highest yields for every pixel, all params \n  yld_secano.2 = yld_secano # make backup with varieties\n  yld_riego.2 = yld_riego\n  yld_secano = array(NA, dim = c(dim(crop_secano)[1], length(anos), (p-1)))  #pixels x years x models x params\n  yld_riego = array(NA, dim = c(dim(crop_riego)[1], length(anos), (p-1)))\n  for(k in 1:length(variedades)){\n    yld_secano[wfd.s.best == k,,] = yld_secano.2[wfd.s.best == k,,,k]\n    yld_riego[wfd.r.best == k,,] = yld_riego.2[wfd.r.best == k,,,k]\n  }\n  \n  # check some crop characteristics for table\n  (sum(crop_secano$secano.area) + sum(crop_riego$riego.area)) # total harvested area\n  sum(c(crop_secano$elev*crop_secano$secano.area,crop_riego$elev*crop_riego$riego.area))/sum(c(crop_secano$secano.area,crop_riego$riego.area))  #area-weighted elevation\n  sum(c(abs(crop_secano$y)*crop_secano$secano.area,abs(crop_riego$y)*crop_riego$riego.area))/sum(c(crop_secano$secano.area,crop_riego$riego.area))  #area-weighted latitude\n  \n  sum(crop_secano$secano.area)/1000000  #rainfed\n  sum(crop_secano$elev*crop_secano$secano.area)/sum(crop_secano$secano.area)  #area-weighted elevation\n  sum(abs(crop_secano$y)*crop_secano$secano.area)/sum(crop_secano$secano.area)  #area-weighted latitude\n  \n  sum(crop_riego$riego.area)/1000000  #irrigated\n  sum(crop_riego$elev*crop_riego$riego.area)/sum(crop_riego$riego.area)  #area-weighted elevation\n  sum(abs(crop_riego$y)*crop_riego$riego.area)/sum(crop_riego$riego.area)  #area-weighted latitude\n  \n  # Look at harvested area by country and FPU\n  areas = c(crop_secano$secano.area, crop_riego$riego.area)\n  countries = c(crop_secano$country, crop_riego$country)\n  areas.country = aggregate(areas, by = list(countries), FUN = sum)\n  sum(areas.country$x)\n  areas.country[order(areas.country$x, decreasing = T),]\n  \n  fpus = c(as.character(crop_secano$New_FPU), as.character(crop_riego$New_FPU))\n  areas.fpu = aggregate(areas, by = list(fpus), FUN = sum)\n  sum(areas.fpu$x)\n  areas.fpu[order(areas.fpu$x, decreasing = T),]\n  \n  # Filter out bad pixels with excess crop failures\n  # contar # de NA y 0 en rendimiento\n  riego.fallas = apply(yld_riego, c(1, 3), function(x) sum(is.na(x) | x == 0))\n  secano.fallas = apply(yld_secano, c(1, 3), function(x) sum(is.na(x) | x == 0))\n  \n  # filtrar pixeles con muchas fallas en WFD\n  ind.bad.r = which(riego.fallas[,10] >= 14)  #half of total years\n  ind.bad.s = which(secano.fallas[,10] >= 14)\n  if (length(ind.bad.r) > 0) {yld_riego = yld_riego[-ind.bad.r,,]\n  crop_riego2 = crop_riego  # make backup of original\n  crop_riego = crop_riego[-ind.bad.r,]}\n  if (length(ind.bad.s) > 0) {yld_secano = yld_secano[-ind.bad.s,,]\n  crop_secano2 = crop_secano  #make backup of original\n  crop_secano = crop_secano[-ind.bad.s,]}\n  \n  # #Set NA to 0 for crop failure\n  # yld_secano[is.na(yld_secano)] = 0\n  # yld_riego[is.na(yld_riego)] = 0\n  \n  # Aggregate yields to COUNTRY-SCALE\n  # get list of countries\n  countries = as.character(na.omit(unique(c(as.character(crop_riego$country), as.character(crop_secano$country)))))\n  \n  # Calculate weighted averages by model & compare to WFD\n  area.riego = replicate(length(anos), crop_riego$riego.area)  #keep same dimension as yield matrix\n  area.secano = replicate(length(anos), crop_secano$secano.area)\n  \n  # Aggregate to country scale for all models & years (across riego & secano)\n  yld.country = array(NA, dim = c(length(countries), length(anos), 10))  #initialize matrices (years x country x model )\n  dimnames(yld.country)[1] = list(countries)\n  dimnames(yld.country)[2] = list(anos2) \n  dimnames(yld.country)[3] = list(models[1:10,])\n  for(r in 1:length(countries)){ # loop by country\n    \n    ind.reg.r = which(crop_riego$country == countries[r])\n    ind.reg.s = which(crop_secano$country == countries[r])\n    \n    if(length(c(ind.reg.r, ind.reg.s)) >= 1){\n      for(m in 1:10){\n        prod_riego.m = yld_riego[ind.reg.r,,m] * area.riego[ind.reg.r,] # calculate production by pixel\n        prod_secano.m = yld_secano[ind.reg.s,,m] * area.secano[ind.reg.s,]\n        prod_all = rbind(prod_riego.m, prod_secano.m) # stack riego & secano\n        area_all = rbind(area.riego[ind.reg.r,], area.secano[ind.reg.s,]) # same for area\n        yld.country[r,,m] = apply(prod_all,2,sum)/apply(area_all, 2, sum) # sum production at country-scale & divide out by total area\n      }\n    }\n  }\n  \n  # calculate interannual means in each period\n  yld.country.m = apply(yld.country, c(1, 3), mean, na.rm = T)\n  \n  # Calculate percent change in yield between each model & WFD with bootstrapping for CI\n  pct.ch.country = (apply(yld.country.m[,1:9], 1, mean) - yld.country.m[,10])/yld.country.m[,10] * 100\n  boot = mat.or.vec(500, length(countries)) # bootstrap results\n  for(j in 1:500){boot.ind = sample(1:(p-2), (p-2), replace = T)\n  boot[j,] = (apply(yld.country.m[,boot.ind], 1, mean) - yld.country.m[,10])/yld.country.m[,10] * 100}\n  pct.ch.country.CI = apply(boot, 2, function(x) quantile(x, c(.05, .95), na.rm = T))\n  colnames(pct.ch.country.CI) = countries\n  \n  # Save results \n  eval(parse(text = paste(\"save(yld.country.m, file = './FAOSTAT_validation/ylds_\", crops[i], \"_optVariety.Rdat')\", sep = \"\")))\n  eval(parse(text = paste(\"save(pct.ch.country, pct.ch.country.CI, file = './FAOSTAT_validation/country.pctCh_\", crops[i], \"_optVariety.Rdat')\", sep = \"\")))\n  \n  ## GRAPH YIELD CHANGES ##\n  # Color-code country labels by region\n  regions = character(length(countries))\n  ind.NOR = match(countries, NOR)\n  regions[which(is.na(ind.NOR) == F)] = 'darkorange' # yellow\n  ind.CEN = match(countries, CEN)\n  regions[which(is.na(ind.CEN) == F)] = 'yellow' # orange\n  ind.BRA = match(countries, BRA)\n  regions[which(is.na(ind.BRA) == F)] = 'green2'\n  ind.AND = match(countries, AND)\n  regions[which(is.na(ind.AND) == F)] = 'royalblue3'\n  ind.SUR = match(countries, SUR)\n  regions[which(is.na(ind.SUR) == F)] = 'red3'\n  \n  ind.sort = order(pct.ch.country)  #sort by yield change values\n  \n  # Create barplot\n  par(mar=c(6.5, 4.1, 2.1, 2.1))\n  barplot2(pct.ch.country[ind.sort], width = 0.8, xlim = c(0, 38), col = regions[ind.sort], yaxt = 'n', xaxt = 'n',\n           ylim = c(-55, 55), xlab = '', space = 1, plot.ci = T, ci.l = pct.ch.country.CI[1, ind.sort], ci.u = pct.ch.country.CI[2, ind.sort])\n  axis(side = 2, at = seq(-55, 55, 10))\n  abline(h = 0)\n  # text(seq(1.5,length(countries)*2,by=2), par(\"usr\")[3]-0.25, \n  #      srt = 60, adj= 1, xpd = TRUE,\n  #      labels = paste(countries[ind.sort]), cex=0.85)\n  text(seq(0.8, length(countries) * 0.8 * 2, by = 0.8 * 2), par(\"usr\")[3]-7, \n       srt = 55, adj = 1, xpd = TRUE,\n       labels = paste(countries[ind.sort]), cex = 0.8)\n  \n  ## CROP FAILURES ##\n  ## Aggregate area with crop failures to country-scale\n  # first identify crop failures by pixel & year\n  thresh = mean(yld_secano[,,10]) * 0.05  #5% of mean rainfed yield is considered \"failure\"\n  # thresh = 50\n  riego.fail = (yld_riego <= thresh | is.na(yld_riego)) * 1\n  secano.fail = (yld_secano <= thresh | is.na(yld_secano)) * 1\n  \n  fail.country = array(NA, dim = c(length(countries), length(anos), 10)) # initialize matrices (years x country x model)\n  dimnames(fail.country)[1] = list(countries)\n  dimnames(fail.country)[2] = list(anos2) \n  dimnames(fail.country)[3] = list(models[1:10,])\n  for(r in 1:length(countries)){ # loop by country\n    \n    ind.reg.r = which(crop_riego$country == countries[r])\n    ind.reg.s = which(crop_secano$country == countries[r])\n    \n    if(length(c(ind.reg.r, ind.reg.s)) >= 1){\n      \n      for(m in 1:10){\n        \n        fail_riego.m = riego.fail[ind.reg.r,,m] * area.riego[ind.reg.r,] # calculate area with crop failure\n        fail_secano.m = secano.fail[ind.reg.s,,m] * area.secano[ind.reg.s,]\n        fail_all = rbind(fail_riego.m, fail_secano.m) # stack riego & secano\n        area_all = rbind(area.riego[ind.reg.r,], area.secano[ind.reg.s,])\n        fail.country[r,,m] = apply(fail_all, 2, sum)/apply(area_all, 2, sum) * 100 # sum area with crop failure at country-scale, divide by total area to get %\n      }\n    }\n  }\n  \n  # Calculate interannual means in each period\n  fail.country.m = apply(fail.country, c(1, 3), mean)\n  \n  # Calculate multi-model mean in future period, put with baseline\n  fail.compare = cbind(fail.country.m[,10], apply(fail.country.m[,1:9], 1, mean))\n  colnames(fail.compare) = c('Historical', 'Future')\n  \n  # Calculate confidence intervals\n  boot = mat.or.vec(500, length(countries)) # bootstrap results\n  for(j in 1:500){boot.ind = sample(1:(p-2), (p-2), replace = T)\n  boot[j,] = apply(fail.country.m[,boot.ind], 1, mean)}\n  fail.future.CI = apply(boot, 2, function(x) quantile(x, c(.05, .95), na.rm = T))\n  colnames(fail.future.CI) = countries\n  \n  # order results by crop failures in baseline\n  ind.sort = order(fail.compare[,1], decreasing = T)\n  \n  # Save results \n  eval(parse(text = paste(\"save(fail.compare, fail.future.CI, file = './FAOSTAT_validation/country.areaFail_\", crops[i], \"_optVariety.Rdat')\", sep = \"\")))\n  \n  # Try color-coding country labels by region\n  regions = character(length(countries))\n  ind.NOR = match(countries, NOR)\n  regions[which(is.na(ind.NOR) == F)] = 'yellow'\n  ind.CEN = match(countries, CEN)\n  regions[which(is.na(ind.CEN) == F)] = 'darkorange'\n  ind.BRA = match(countries, BRA)\n  regions[which(is.na(ind.BRA) == F)] = 'green2'\n  ind.AND = match(countries, AND)\n  regions[which(is.na(ind.AND) == F)] = 'royalblue3'\n  ind.SUR = match(countries, SUR)\n  regions[which(is.na(ind.SUR) == F)] = 'red3'\n  \n  # Create barplot\n  barplot2(t(fail.compare[ind.sort,]), beside = T, ylim = c(0, 30), density = c(NA, 50),\n           col = rbind(regions[ind.sort], regions[ind.sort]), yaxt = 'n', xaxt = 'n', xlab = '',\n           plot.ci = T, ci.l = rbind(NA, fail.future.CI[1, ind.sort]), ci.u = rbind(NA, fail.future.CI[2, ind.sort]))\n  axis(side = 2, at = seq(0, 30, 5))\n  abline(h = 0)\n  text(seq(1.5, length(countries) * 3, by = 3), par(\"usr\")[3]-0.25, \n       srt = 60, adj = 1, xpd = TRUE,\n       labels = paste(countries[ind.sort]), cex = 0.85)\n  \n  ## Try a plot only showing countries with significant changes in crop failures \n  # sig.ch = which((fail.future.CI[1,]>fail.compare[,1]|fail.future.CI[2,]<fail.compare[,1])&((fail.compare[,2]>5)|(fail.compare[,1]>5)))  #(and past or future >5%)\n  # sig.ch = which((fail.future.CI[1,]>fail.compare[,1]|fail.future.CI[2,]<fail.compare[,1]))\n  # sig.ch = which((fail.future.CI[1,]>fail.compare[,1]|fail.future.CI[2,]<fail.compare[,1]))  #(no 5% rule)\n  change = fail.compare[,2] - fail.compare[,1]\n  sig.ch = which((fail.future.CI[1,] > fail.compare[,1] | fail.future.CI[2,] < fail.compare[,1]) & abs(change) > 2) # (significant & change > 2%)\n  \n  fail.compare.2 = fail.compare[sig.ch,]\n  fail.future.CI.2 = fail.future.CI[,sig.ch]\n  countries.2 = countries[sig.ch]\n  \n  regions = character(length(countries.2))\n  ind.NOR = match(countries.2, NOR)\n  regions[which(is.na(ind.NOR) == F)] = 'darkorange'\n  ind.CEN = match(countries.2, CEN)\n  regions[which(is.na(ind.CEN) == F)] = 'yellow'\n  ind.BRA = match(countries.2, BRA)\n  regions[which(is.na(ind.BRA) == F)] = 'green2'\n  ind.AND = match(countries.2, AND)\n  regions[which(is.na(ind.AND) == F)] = 'royalblue3'\n  ind.SUR = match(countries.2, SUR)\n  regions[which(is.na(ind.SUR) == F)] = 'red3'\n  \n  # Handle one country only\n  if(length(countries.2) == 1){\n    change = fail.compare.2[2] - fail.compare.2[1]\n    if(change < 0){ind.sort3 = c(NA, 1)} else {ind.sort3 = c(1, NA)}\n  } else {\n    change = fail.compare.2[,2] - fail.compare.2[,1]\n    pos = names(which(change > 0))\n    pos = pos[order(fail.compare.2[which(change > 0), 2], decreasing = T)] # order by future values\n    neg = names(which(change < 0))\n    neg = neg[order(fail.compare.2[which(change < 0), 2], decreasing = T)]\n    ind.sort3 = match(c(pos, NA, neg), names(change)) # sort by future, first positive, then negative changes\n  }\n  \n  # ind.sort = order(fail.compare.2[,1],decreasing=T)\n  # change.CI = cbind(fail.future.CI.2[1,]-fail.compare.2[,1],fail.future.CI.2[2,]-fail.compare.2[,1])\n  # ind.sort = order(change,decreasing=T)\n  # ind.sort2 = order(fail.compare.2[,2],decreasing=T)  #sort by future values\n  \n  #adjust colors for NA's\n  cols = regions[ind.sort3]\n  cols[is.na(cols)] = 'black'\n  \n  # #look at changes\n  # barplot2(rbind(fail.compare.2[ind.sort,1],change[ind.sort]),width=0.8,xlim=c(0,48),beside=T,ylim=c(-10,25),density=c(NA,50),col=rbind(regions[ind.sort],regions[ind.sort]),yaxt='n',xaxt='n',xlab='',plot.ci=T,ci.l=rbind(NA,change.CI[ind.sort,1]),ci.u=rbind(NA,change.CI[ind.sort,2]))\n  # axis(side = 2, at = seq(-10,25,5))\n  # abline(h=0)\n  # text(seq(0.8,length(countries.2)*0.8*3,by=0.8*3), par(\"usr\")[3]-0.25, \n  #      srt = 60, adj= 1, xpd = TRUE,\n  #      labels = paste(countries.2[ind.sort]), cex=0.85)\n  \n  # look at baseline vs. future values \n  if(length(countries.2) == 1){\n    barplot2(cbind(NA, fail.compare.2), width = 0.8, xlim = c(0, 48), beside = T, ylim = c(0, 40),\n             density = c(NA, 40), col = rbind(cols, cols), yaxt = 'n', xaxt = 'n', xlab = '', plot.ci = T,\n             ci.l = cbind(NA, c(NA, fail.future.CI.2[1])), ci.u = cbind(NA, c(NA, fail.future.CI.2[2])))\n  } else{\n    barplot2(t(fail.compare.2[ind.sort3,]), width = 0.8, xlim = c(0, 48), beside = T, ylim = c(0,40),\n             density = c(NA, 40), col = rbind(cols, cols), yaxt = 'n', xaxt = 'n', xlab = '', plot.ci = T,\n             ci.l = rbind(NA, fail.future.CI.2[1, ind.sort3]), ci.u = rbind(NA, fail.future.CI.2[2, ind.sort3]))\n  }\n  axis(side = 2, at = seq(0, 40, 5))\n  abline(h = 0)\n  abline(v = which(is.na(ind.sort3)) * (0.8 * 3) - 1.2, lty = 3)\n  test = paste(countries.2[ind.sort3])\n  test[test == 'NA'] = '' # fix NA in labels\n  text(seq(0.8, length(countries.2[ind.sort3]) * 0.8 * 3, by = 0.8 * 3), par(\"usr\")[3]-0.5, \n       srt = 55, adj = 1, xpd = TRUE,\n       labels = paste(test), cex = 0.9)\n  #legend('topright',c('Baseline','Future'),fill=c('black','black'),density=c(NA,40))\n  \n  ## LOOK AT YIELDS & YIELD CHANGES AT FPU SCALE\n  # get list of countries\n  FPUs = unique(c(as.character(crop_riego$New_FPU), as.character(crop_secano$New_FPU)))\n  \n  # Calculate weighted averages by model & compare to WFD\n  area.riego = replicate(length(anos), crop_riego$riego.area)  #keep same dimension as yield matrix\n  area.secano = replicate(length(anos), crop_secano$secano.area)\n  \n  # Aggregate to FPU scale for all models & years (across riego & secano)\n  yld.FPU = array(NA, dim = c(length(FPUs), length(anos), 10))  #initialize matrices (years x country x model )\n  dimnames(yld.FPU)[1] = list(FPUs)\n  dimnames(yld.FPU)[2] = list(anos2) \n  dimnames(yld.FPU)[3] = list(models[1:10,])\n  for(r in 1:length(FPUs)){ # loop by FPU\n    \n    ind.reg.r = which(crop_riego$New_FPU == FPUs[r])\n    ind.reg.s = which(crop_secano$New_FPU == FPUs[r])\n    print(FPUs[r])\n    \n    if(length(c(ind.reg.r, ind.reg.s)) >= 1){\n      for(m in 1:10){\n        prod_riego.m = yld_riego[ind.reg.r,,m] * area.riego[ind.reg.r,] # calculate production by pixel\n        prod_secano.m = yld_secano[ind.reg.s,,m] * area.secano[ind.reg.s,]\n        prod_all = rbind(prod_riego.m, prod_secano.m) # stack riego & secano\n        area_all = rbind(area.riego[ind.reg.r,], area.secano[ind.reg.s,]) # same for area\n        yld.FPU[r,,m] = apply(prod_all, 2, sum)/apply(area_all, 2, sum)  #sum production at country-scale & divide out by total area\n      }\n    }\n  }\n  \n  # calculate interannual means in each period\n  yld.FPU.m = apply(yld.FPU, c(1, 3), mean, na.rm = T)\n  \n  # Calculate percent change in yield between each model & WFD with bootstrapping for CI\n  pct.ch.FPU = (apply(yld.FPU.m[,1:9], 1, mean) - yld.FPU.m[,10])/yld.FPU.m[,10] * 100\n  boot = mat.or.vec(500, length(FPUs)) # bootstrap results\n  for(j in 1:500){boot.ind = sample(1:(p-2), (p-2), replace = T)\n  boot[j,] = (apply(yld.FPU.m[,boot.ind], 1, mean) - yld.FPU.m[,10])/yld.FPU.m[,10] * 100}\n  pct.ch.FPU.CI = apply(boot, 2, function(x) quantile(x, c(.05, .95), na.rm = T))\n  colnames(pct.ch.FPU.CI) = FPUs\n  \n  # Save results \n  eval(parse(text = paste(\"save(pct.ch.FPU, pct.ch.FPU.CI, file = './FAOSTAT_validation/country.pctCh_\", crops[i], \"_optVariety_FPU.Rdat')\", sep = \"\")))\n  \n  # Aggregate area with crop failures to REGIONAL scale\n  # first identify crop failures by pixel & year\n  thresh = mean(yld_secano[,,10]) * 0.05 # 5% of mean rainfed yield is considered \"failure\"\n  riego.fail = (yld_riego <= thresh | is.na(yld_riego)) * 1\n  secano.fail = (yld_secano <= thresh | is.na(yld_secano)) * 1\n  \n  # Add region2 classification to crop matrices\n  regions2 = c('NOR', 'CEN', 'BRA', 'AND', 'SUR')\n  for(j in 1:5){\n    eval(parse(text = paste('ind.', regions2[j], ' = match(crop_riego$country,', regions2[j], ')', sep = '')))\n    eval(parse(text = paste('crop_riego$region2[is.na(ind.', regions2[j], ') == F] = \"', regions2[j], '\"', sep = '')))\n    \n    eval(parse(text = paste('ind.', regions2[j], ' = match(crop_secano$country,', regions2[j], ')', sep = '')))\n    eval(parse(text = paste('crop_secano$region2[is.na(ind.', regions2[j], ') == F] = \"', regions2[j], '\"', sep = '')))\n  }\n  \n  fail.region = array(NA, dim = c(5, length(anos), 10)) # Initialize matrices (regions x years x model)\n  dimnames(fail.region)[1] = list(regions2)\n  dimnames(fail.region)[2] = list(anos2) \n  dimnames(fail.region)[3] = list(models[1:10,])\n  for(r in 1:5){ # loop by region\n    \n    ind.reg.r = which(crop_riego$region2 == regions2[r])  \n    ind.reg.s = which(crop_secano$region2 == regions2[r])\n    \n    if(length(c(ind.reg.r, ind.reg.s)) >= 1){\n      for(m in 1:10){\n        \n        fail_riego.m = riego.fail[ind.reg.r,,m] * area.riego[ind.reg.r,] # calculate area with crop failure\n        fail_secano.m = secano.fail[ind.reg.s,,m] * area.secano[ind.reg.s,]\n        fail_all = rbind(fail_riego.m, fail_secano.m) # stack riego & secano\n        area_all = rbind(area.riego[ind.reg.r,], area.secano[ind.reg.s,])\n        fail.region[r,,m] = apply(fail_all, 2, sum)/apply(area_all, 2, sum) * 100 # Sum area with crop failure at country-scale, divide by total area to get %\n      }\n    }\n  }\n  \n  # Calculate interannual means in each period\n  fail.region.m = apply(fail.region, c(1, 3), mean)\n  \n  # Calculate multi-model mean in future period, put with baseline\n  fail.compare = cbind(fail.region.m[,10], apply(fail.region.m[,1:9], 1, mean))\n  colnames(fail.compare) = c('Historical', 'Future')\n  \n  # calculate confidence intervals\n  boot = mat.or.vec(500, length(regions2)) # bootstrap results\n  for(j in 1:500){boot.ind = sample(1:(p-2), (p-2), replace = T)\n  boot[j,] = apply(fail.region.m[,boot.ind], 1, mean)}\n  fail.future.CI = apply(boot, 2, function(x) quantile(x, c(.05, .95), na.rm = T))\n  colnames(fail.future.CI) = regions2\n  \n  # #order results by crop failures in baseline\n  # ind.sort = order(fail.compare[,1],decreasing=T)\n  \n  # Save results \n  eval(parse(text = paste(\"save(fail.compare, fail.future.CI, file = './FAOSTAT_validation/regions.areaFail_\", crops[i], \"_optVariety.Rdat')\", sep = \"\")))\n  \n  # Color-code regions\n  colors = c('darkorange', 'yellow', 'green2', 'royalblue3', 'red3')\n  \n  # create barplot\n  barplot2(t(fail.compare), beside = T, ylim = c(0, 20), density = c(NA, 50), col = rbind(colors, colors),\n           yaxt = 'n', xaxt = 'n', xlab = '', plot.ci = T, ci.l = rbind(NA, fail.future.CI[1,]), ci.u = rbind(NA, fail.future.CI[2,]))\n  axis(side = 2, at = seq(0, 20, 5))\n  abline(h = 0)\n  text(seq(1.5, length(regions2) * 3, by = 3), par(\"usr\")[3]-0.25,\n       srt = 60, adj = 1, xpd = TRUE,\n       labels = paste(regions2), cex = 0.85)\n  \n  return(cat(paste0(\"Process done for: \", crops[i], \"!\\n\")))\n  \n})\n",
    "created" : 1498595927643.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2973453705",
    "id" : "AA73B6EA",
    "lastKnownWriteTime" : 1499701270,
    "last_content_update" : 1499800677292,
    "path" : "D:/ToBackup/climate_and_crop_modelling/bid-cc-agricultural-sector/replicate_bid_report/Agregar_rend_country_yields_cropFailures.R",
    "project_path" : "Agregar_rend_country_yields_cropFailures.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}