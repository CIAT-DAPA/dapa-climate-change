{
    "collab_server" : "",
    "contents" : "g <- gc(); rm(list = ls())\n\n# R options\noptions(warn = -1); options(scipen = 999); OSys <- Sys.info(); OSys <- OSys[names(OSys)==\"sysname\"]\n\nif(OSys == \"Windows\"){\n  setwd(\"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector/22-Redo-BID-report\")\n} else {\n  if(OSys == \"Linux\"){\n    setwd(\"/mnt/workspace_cluster_3/bid-cc-agricultural-sector/22-Redo-BID-report\")\n  }\n}\n\n# Load libraries\nsuppressMessages(library(Hmisc))\nsuppressMessages(library(raster))\nsuppressMessages(library(ggplot2))\nsuppressMessages(library(reshape))\nsuppressMessages(library(RColorBrewer))\n\n# Escoger parametro de interes\nparams <- c('HWAH', 'MDAT', 'PDAT', 'NDCH') #,'PDAT','EPCM') # Duracion, rendimiento y otro variables\n\ncrops <- c('Maize', 'Rice', 'Soybean', 'Bean', 'Wheat')\nlapply(1:length(crops), function(i){\n  \n  if(crops[i] == \"Maize\"){variedades <- c(\"H6\", \"FM6\", \"MCCURDY6714\")}\n  if(crops[i] == \"Rice\"){variedades <- c(\"IR8\", \"IR72\", \"IR64\")}\n  if(crops[i] == \"Soybean\"){variedades <- c(\"Hutcheson\", \"DONMARIO\")}\n  if(crops[i] == \"Bean\"){variedades <- c(\"ICTAOstua\", \"Carioca\", \"A193\", \"BAT881\", \"Manitou\", \"Perola\", \"BRSRadiante\")}\n  if(crops[i] == \"Wheat\"){variedades <- c(\"Seri82BA\", \"TajanBA\", \"DonErnestoBA\", \"Gerek79BA\", \"HalconsnaBA\", \"BrigadierBA\")}\n  \n  # Set paths\n  if(OSys == \"Windows\"){\n    path.res = \"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector/19-BID-reanalysis\" # Results directory\n    path.root = \"//dapadfs/workspace_cluster_3/bid-cc-agricultural-sector\" # Root path\n  } else {\n    if(OSys == \"Linux\"){\n      path.res = \"/mnt/workspace_cluster_3/bid-cc-agricultural-sector/19-BID-reanalysis\" # Results directory\n      path.root = \"/mnt/workspace_cluster_3/bid-cc-agricultural-sector\" # Root path\n    }\n  }\n  carp.res.riego = \"historical/final\"\n  carp.res.secano = \"historical/final\"\n  \n  treat = c('riego', 'secano')  #riego o secano (which to plot)\n  treat.en = c('Irrigated', 'Rainfed')\n  cultivos = c('maiz', 'arroz', 'soya', 'frijol', 'trigo')\n  cultivos.en = c('Maize', 'Rice', 'Soybeans', 'Bean', 'Wheat')\n  anos = 1:29 # Fijar years para analizar aqui (leave extra year at end)\n  anos2 = 1971:1999\n  \n  # Get list of climate models\n  models = read.table(paste(path.root, '/_documentos/ModelosGCM.csv', sep = ''), header = T, sep = ',', stringsAsFactors = F)\n  models = rbind(models, 'Historical baseline', 'Future multi-GCM average')\n  p = dim(models)[1]\n  colnames(models) = 'Models' #hack for now (machetazo)\n  \n  # Load pixel id's\n  eval(parse(text = paste('load(\"', path.root, '/08-Cells_toRun/matrices_cultivo/version2017/', cultivos.en[i], '_riego.Rdat\")', sep = '')))\n  eval(parse(text = paste('load(\"', path.root, '/08-Cells_toRun/matrices_cultivo/version2017/', cultivos.en[i], '_secano.Rdat\")', sep = '')))\n  \n  # Initialize data matrices\n  dat_secano = array(NA, dim = c(dim(crop_secano)[1], 30, length(params), length(variedades)))  #initialize arrays\n  dat_riego = array(NA, dim = c(dim(crop_riego)[1], 30, length(params), length(variedades)))\n  \n  # Loop through varieties\n  for (v in 1:length(variedades)){\n    \n    # load, unlist and extract WFD yield data to arrays (gridcells x years x params)\n    if(crops[i] == \"Soybean\"){\n      load(paste(path.res, '/', crops[i], '/', carp.res.secano, '/SOY_rainfed_', variedades[v], '_WFD.Rdat', sep = ''))\n    } else {\n      load(paste(path.res, '/', crops[i], '/', carp.res.secano, '/', toupper(crops[i]), '_rainfed_', variedades[v], '_WFD.Rdat', sep = ''))\n    }\n    Run.secano = Run\n    if(crops[i] == \"Soybean\"){\n      load(paste(path.res, '/', crops[i], '/', carp.res.riego, '/SOY_irrigation_', variedades[v], '_WFD.Rdat', sep = ''))\n    } else {\n      load(paste(path.res, '/', crops[i], '/', carp.res.riego, '/', toupper(crops[i]), '_irrigation_', variedades[v], '_WFD.Rdat', sep = ''))\n    }\n    Run.riego = Run\n    \n    # unlist everything into matrices\n    for (j in 1:length(Run.secano))  {\n      if (is.null(dim(Run.secano[[j]])))  {\n        dat_secano[j,,,] = NA\n      }  else{\n        for (p2 in 1:length(params)) {\n          ind.s = as.numeric(substr(Run.secano[[j]][,1],1,4))-1970  #index based on simulation start date\n          if (ind.s[1]==0)  {ind.s = ind.s +1}\n          dat_secano[j,ind.s,p2,v] = as.numeric(as.character(Run.secano[[j]][,params[p2]]))\n        }\n      }\n    }\n    \n    for (j in 1:length(Run.riego))  {\n      if (is.null(dim(Run.riego[[j]])))  {\n        dat_riego[j,,,] = NA\n      }  else{\n        for (p2 in 1:length(params)) {\n          ind.r = as.numeric(substr(Run.riego[[j]][,1],1,4))-1970\n          if (ind.r[1]==0)  {ind.r = ind.r +1}\n          dat_riego[j,ind.r,p2,v] = as.numeric(as.character(Run.riego[[j]][,params[p2]]))\n        }\n      }\n    }\n  }\n  \n  # Check data by year\n  # apply(dat_riego[,,1,3],2,function(x) sum(is.na(x)==F)) # yield for 3rd variety\n  # apply(dat_secano[,,1,2],2,function(x) sum(is.na(x)==F))\n  \n  # Descartar los years sin datos climaticos, luego reemplaza -99 con 0 (para fallas); no debe existir fallas en DSSAT por razones tecnicas\n  yld_secano = dat_secano[,anos,1,] # Incluir los indices de los years \"buenos\" aqui con datos por todos los pixeles\n  yld_riego = dat_riego[,anos,1,]\n  yld_secano[yld_secano==-99] = 0 # Reemplazar -99 con 0 para rendimiento\n  yld_riego[yld_riego==-99] = 0\n  fechas_secano = dat_secano[,anos,2:4,]\n  fechas_riego = dat_riego[,anos,2:4,]\n  fechas_secano[fechas_secano==-99] = NA # Reemplazar -99 con NA para fechas de siembra y cosecha\n  fechas_riego[fechas_riego==-99] = NA\n  \n  # Identify best variety in historical baseline (higher mean yields & less crop failures)\n  # across all varieties\n  wfd.r = apply(yld_riego,c(1,3),mean,na.rm=T)  #multi-annual means\n  wfd.s = apply(yld_secano,c(1,3),mean,na.rm=T)\n  thresh = mean(yld_secano,na.rm=T)*0.2  #define crop failure as 20% of mean rainfed yield\n  wfd.fail.r = apply(yld_riego,c(1,3),function(x) sum(x<thresh,na.rm=T))  #multi-annual means\n  wfd.fail.s = apply(yld_secano,c(1,3),function(x) sum(x<thresh,na.rm=T))\n  \n  # Highest-yielding variety\n  wfd.r.high = apply(wfd.r,1,which.max)\n  wfd.s.high = apply(wfd.s,1,which.max)\n  \n  # High-yielding and no more than 4 crop failures (15%)\n  if(crops[i] %in% c(\"Maize\", \"Rice\")){\n    \n    wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n    for (j in 1:dim(wfd.s)[1])  {\n      sortYield = sort.list(wfd.s[j,], dec = T)\n      if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n        if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n          if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n            wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n    }\n    \n    wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n    for (j in 1:dim(wfd.r)[1])  {\n      sortYield = sort.list(wfd.r[j,], dec = T) \n      if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n        if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n          if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n            wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n    }\n    \n  } else {\n    if(crops[i] == \"Soybean\"){\n      \n      wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n      for (j in 1:dim(wfd.s)[1])  {\n        sortYield = sort.list(wfd.s[j,], dec = T)\n        if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n          if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n            wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n      \n      wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n      for (j in 1:dim(wfd.r)[1])  {\n        sortYield = sort.list(wfd.r[j,], dec = T) \n        if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n          if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n            wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n          }\n        }\n      }\n      \n    } else {\n      if(crops[i] == \"Bean\"){\n        \n        wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n        for (j in 1:dim(wfd.s)[1])  {\n          sortYield = sort.list(wfd.s[j,], dec = T)\n          if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n            if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n              if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n                if (wfd.fail.s[j,sortYield[4]] <= 4) {wfd.s.best[j] = sortYield[4]} else{\n                  if (wfd.fail.s[j,sortYield[5]] <= 4) {wfd.s.best[j] = sortYield[5]} else{\n                    if (wfd.fail.s[j,sortYield[6]] <= 4) {wfd.s.best[j] = sortYield[6]} else{\n                      if (wfd.fail.s[j,sortYield[7]] <= 4) {wfd.s.best[j] = sortYield[7]} else{\n                        wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        \n        wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n        for (j in 1:dim(wfd.r)[1])  {\n          sortYield = sort.list(wfd.r[j,], dec = T) \n          if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n            if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n              if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n                if (wfd.fail.r[j,sortYield[4]] <= 4) {wfd.r.best[j] = sortYield[4]} else{\n                  if (wfd.fail.r[j,sortYield[5]] <= 4) {wfd.r.best[j] = sortYield[5]} else{\n                    if (wfd.fail.r[j,sortYield[6]] <= 4) {wfd.r.best[j] = sortYield[6]} else{\n                      if (wfd.fail.r[j,sortYield[7]] <= 4) {wfd.r.best[j] = sortYield[7]} else{\n                        wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        \n      } else {\n        if(crops[i] == \"Wheat\"){\n          \n          wfd.s.best = mat.or.vec(dim(wfd.s)[1], 1)\n          for (j in 1:dim(wfd.s)[1])  {\n            sortYield = sort.list(wfd.s[j,], dec = T)\n            if (wfd.fail.s[j,sortYield[1]] <= 4) {wfd.s.best[j] = sortYield[1]}  else{\n              if (wfd.fail.s[j,sortYield[2]] <= 4) {wfd.s.best[j] = sortYield[2]}  else{\n                if (wfd.fail.s[j,sortYield[3]] <= 4) {wfd.s.best[j] = sortYield[3]}  else{\n                  if (wfd.fail.s[j,sortYield[4]] <= 4) {wfd.s.best[j] = sortYield[4]} else{\n                    if (wfd.fail.s[j,sortYield[5]] <= 4) {wfd.s.best[j] = sortYield[5]} else{\n                      if (wfd.fail.s[j,sortYield[6]] <= 4) {wfd.s.best[j] = sortYield[6]} else{\n                        wfd.s.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          \n          wfd.r.best = mat.or.vec(dim(wfd.r)[1], 1)\n          for (j in 1:dim(wfd.r)[1])  {\n            sortYield = sort.list(wfd.r[j,], dec = T) \n            if (wfd.fail.r[j,sortYield[1]] <= 4) {wfd.r.best[j] = sortYield[1]}  else{\n              if (wfd.fail.r[j,sortYield[2]] <= 4) {wfd.r.best[j] = sortYield[2]}  else{\n                if (wfd.fail.r[j,sortYield[3]] <= 4) {wfd.r.best[j] = sortYield[3]}  else{\n                  if (wfd.fail.r[j,sortYield[4]] <= 4) {wfd.r.best[j] = sortYield[4]} else{\n                    if (wfd.fail.r[j,sortYield[5]] <= 4) {wfd.r.best[j] = sortYield[5]} else{\n                      if (wfd.fail.r[j,sortYield[6]] <= 4) {wfd.r.best[j] = sortYield[6]} else{\n                        wfd.r.best[j] = sortYield[1]  #if all varieties have more than 4 crop failures, use highest-yielding\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          \n        }\n      }\n    }\n  }\n  \n  # Just pick highest-yielding by growth habit for dry bean\n  if(crops[i] == 'Bean'){ # Check highest yielding by country according to growth habit\n    habit = read.table(paste0(path.root, '/_documentos/Bean_growthHabit.csv'), header = T, sep = ',')\n    for(t in 1:2){\n      eval(parse(text = paste(\"meso = match(crop_\", treat[t], \"$country, habit$X[habit$Mesoamerican == 1])\", sep=\"\")))\n      ind.meso = which(is.na(meso) == F)\n      ind.andean = which(is.na(meso))\n      eval(parse(text = paste(\"meso.high = apply(wfd.\", substr(treat[t], 1, 1), \"[ind.meso, 1:2], 1, which.max)\", sep = \"\")))\n      eval(parse(text = paste(\"andean.high = apply(wfd.\", substr(treat[t], 1, 1), \"[ind.andean, 3:4], 1, which.max)+2\", sep = \"\")))\n      eval(parse(text = paste(\"wfd.\", substr(treat[t], 1, 1), \".best[ind.meso] = meso.high\", sep = \"\")))\n      eval(parse(text = paste(\"wfd.\", substr(treat[t], 1, 1),\".best[ind.andean] = andean.high\", sep = \"\")))\n    }\n  }\n  \n  # Select yield (& dates) for best variety for every pixel \n  yld_secano.2 = yld_secano # make backup with varieties\n  yld_riego.2 = yld_riego\n  fechas_secano.2 = fechas_secano # make backup with varieties\n  fechas_riego.2 = fechas_riego\n  yld_secano = array(NA, dim = c(dim(crop_secano)[1], length(anos))) # pixels x years\n  yld_riego = array(NA, dim = c(dim(crop_riego)[1], length(anos)))\n  fechas_secano = array(NA, dim = c(dim(crop_secano)[1], length(anos),3)) # pixels x years\n  fechas_riego = array(NA, dim = c(dim(crop_riego)[1], length(anos),3)) # pixels x years x params\n  \n  # #to pick just one variety\n  # yld_secano = yld_secano.2[,,2]\n  # yld_riego = yld_riego.2[,,2]\n  # fechas_secano = fechas_secano.2[,,,2]\n  # fechas_riego = fechas_riego.2[,,,2]\n  \n  # Optimal variety\n  for(k in 1:length(variedades)){\n    yld_secano[wfd.s.best==k,] = yld_secano.2[wfd.s.best==k,,k]\n    yld_riego[wfd.r.best==k,] = yld_riego.2[wfd.r.best==k,,k]\n    fechas_secano[wfd.s.best==k,,] = fechas_secano.2[wfd.s.best==k,,,k]\n    fechas_riego[wfd.r.best==k,,] = fechas_riego.2[wfd.r.best==k,,,k]\n  }\n  \n  # Contar # de 0 en rendimiento\n  riego.fallas = apply(yld_riego,1,function(x) sum(is.na(x)|x==0))\n  secano.fallas = apply(yld_secano,1,function(x) sum(is.na(x)|x==0))\n  \n  # Filtrar pixeles con muchas fallas en WFD\n  ind.bad.r = which(riego.fallas>14)\n  ind.bad.s = which(secano.fallas>14)\n  if (length(ind.bad.r)>0) {yld_riego = yld_riego[-ind.bad.r,]\n  fechas_riego = fechas_riego[-ind.bad.r,,]\n  yld_riego.2 = yld_riego.2[-ind.bad.r,,]\n  crop_riego2 = crop_riego # make backup of original\n  crop_riego = crop_riego[-ind.bad.r,]}\n  if (length(ind.bad.s)>0) {yld_secano = yld_secano[-ind.bad.s,]\n  fechas_secano = fechas_secano[-ind.bad.s,,]\n  yld_secano.2 = yld_secano.2[-ind.bad.s,,]\n  crop_secano2 = crop_secano # make backup of original\n  crop_secano = crop_secano[-ind.bad.s,]}\n  \n  # Extract mode of planting & harvest months (across years)\n  siembra.s = apply(fechas_secano[,,2],1,function(x) names(sort(table(format(strptime(x,'%Y %j'),'%m')),dec=T))[1])  \n  siembra.s[sapply(siembra.s, is.null)] <- NA\n  siembra.s = as.numeric(unlist(siembra.s))\n  siembra.r = apply(fechas_riego[,,2],1,function(x) names(sort(table(format(strptime(x,'%Y %j'),'%m')),dec=T))[1])  \n  siembra.r[sapply(siembra.r, is.null)] <- NA\n  siembra.r = as.numeric(unlist(siembra.r))\n  \n  cosecha.s = apply(fechas_secano[,,1],1,function(x) names(sort(table(format(strptime(x,'%Y %j'),'%m')),dec=T))[1])  \n  cosecha.s[sapply(cosecha.s, is.null)] <- NA\n  cosecha.s = as.numeric(unlist(cosecha.s))\n  cosecha.r = apply(fechas_riego[,,1],1,function(x) names(sort(table(format(strptime(x,'%Y %j'),'%m')),dec=T))[1])  \n  cosecha.r[sapply(cosecha.r, is.null)] <- NA\n  cosecha.r = as.numeric(unlist(cosecha.r))\n  \n  # shift years for harvest in next year (Feb or after)\n  colnames(yld_riego) = anos2\n  colnames(yld_secano) = anos2\n  \n  ind.harv.s = which(cosecha.s < siembra.s) # & cosecha.s>=2 \n  yld_secano[ind.harv.s,2:length(anos)] = yld_secano[ind.harv.s,1:(length(anos)-1)] # put in following year when harvest month earlier than sowing\n  yld_secano[ind.harv.s,1] = NA # reset first year to NA\n  \n  ind.harv.r = which(cosecha.r < siembra.r) # & cosecha.r>=2\n  yld_riego[ind.harv.r,2:length(anos)] = yld_riego[ind.harv.r,1:(length(anos)-1)] # put in following year when harvest month earlier than sowing\n  yld_riego[ind.harv.r,1] = NA # reset first year to NA\n  \n  # # I'M NOT SURE WITH THIS\n  # # Exception for Chilean wheat!\n  # ind.chile.s = which(crop_secano$country=='Chile' & cosecha.s>=11) \n  # yld_secano[ind.chile.s,2:length(anos)] = yld_secano[ind.chile.s,1:(length(anos)-1)] # put in following year when harvest in Nov/Dec\n  # yld_secano[ind.chile.s,1] = NA # reset first year to NA\n  \n  # ind.chile.r = which(crop_riego$country=='Chile' & cosecha.r>=11) \n  # yld_riego[ind.chile.r,2:length(anos)] = yld_riego[ind.chile.r,1:(length(anos)-1)]  #put in following year when harvest in Nov/Dec \n  # yld_riego[ind.chile.r,1] = NA  #reset first year to NA\n  \n  # Check NA's by year again\n  # apply(yld_secano,2,function(x) sum(is.na(x)==T))\n  # apply(yld_riego,2,function(x) sum(is.na(x)==T))\n  \n  # Save out yields for comparison with Iizumi\n  save(yld_riego,crop_riego,file=paste('./ylds_evaluacion/',crops[i],'_yld_pixel_riego.Rdat',sep=''))\n  save(yld_secano,crop_secano,file=paste('./ylds_evaluacion/',crops[i],'_yld_pixel_secano.Rdat',sep=''))\n  \n  # Get list of countries\n  countries = unique(c(as.character(crop_riego$country),as.character(crop_secano$country)))\n  \n  # Calculate weighted averages by model & compare to WFD\n  area.riego = replicate(length(anos),crop_riego$riego.area)  #keep same dimension as yield matrix\n  area.secano = replicate(length(anos),crop_secano$secano.area)\n  \n  # Aggregate to country scale for WFD in each model & year (across riego & secano)\n  yld.country = array(NA,dim=c(length(anos),length(countries)))  #initialize matrices\n  colnames(yld.country) = countries\n  rownames(yld.country) = anos2    \n  for (r in 1:length(countries))  {  #loop by country\n    ind.reg.r = which(crop_riego$country==countries[r])\n    ind.reg.s = which(crop_secano$country==countries[r])\n    \n    if (length(c(ind.reg.r,ind.reg.s))>=1)  {\n      for (y in 1:dim(yld.country)[1])  { #loop through years\n        ylds.y = c(yld_riego[ind.reg.r,y],yld_secano[ind.reg.s,y])\n        #ylds.y[is.na(ylds.y)] = 0  #reemplazar NA con 0 for legitimate crop failures\n        areas.y = c(area.riego[ind.reg.r,y],area.secano[ind.reg.s,y])\n        yld.country[y,r] = sum(ylds.y*areas.y)/sum(areas.y)    \n      }\n    }\n  }\n  \n  # Aggregate area by country\n  secano.area = aggregate(crop_secano$secano.area,by=list(crop_secano$country),FUN=sum)\n  riego.area = aggregate(crop_riego$riego.area,by=list(crop_riego$country),FUN=sum)\n  area.merge = merge(secano.area, riego.area, by = \"Group.1\", all = TRUE)\n  area.merge[is.na(area.merge)]=0\n  area.merge$total = area.merge[,2]+area.merge[,3]\n  colnames(area.merge) = c('country','secano','riego','total')\n  \n  # Save results to csv\n  eval(parse(text=paste(\"write.csv(yld.country,file='./FAOSTAT_validation/country.ylds_\",crops[i],\"_optVariety_cosecha.csv')\",sep=\"\")))\n  eval(parse(text=paste(\"write.csv(area.merge,file='./FAOSTAT_validation/country.areas_\",crops[i],\".csv')\",sep=\"\")))\n  \n  return(cat(paste0(\"Process done for: \", crops[i], \"!\\n\")))\n  \n})\n",
    "created" : 1498596472995.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3146129362",
    "id" : "F3834815",
    "lastKnownWriteTime" : 1499701262,
    "last_content_update" : 1499701262210,
    "path" : "D:/ToBackup/climate_and_crop_modelling/bid-cc-agricultural-sector/replicate_bid_report/Agregar_rend_country_optimizar_variedad.R",
    "project_path" : "Agregar_rend_country_optimizar_variedad.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}